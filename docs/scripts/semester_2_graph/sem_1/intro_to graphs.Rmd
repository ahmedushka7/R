---
title: "Введедение в теорию графов"
author: "Ахмедушка"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, highlight = FALSE)
```

### Что такое граф?

**Граф** — абстрактный математический объект, представляющий собой множество вершин графа и набор рёбер, то есть соединений между парами вершин. Вершиной графа могут быть города, а ребрами дорога между городами. Или, например, вершинами могут быть аккаунты в VK. А ребра между ними означает, что два аккаунта находятся в друзьях друг у друга.

Графы бывают разные. На этом семинаре нам важно, что они бывают:

1. **Ориентированные** - ребро(дуга) позволяет добраться из вершины `i` в вершину `j`.
2. **Неориентированные** - ребро позволяет добраться из вершины `i` в вершину `j`, и наоборот.

Способы задания графа:

1. Матрица смежности
2. Матрица инцидентности
3. Список смежности
4. Список рёбер

Нам понадобится только матрица смежности. Важно помнить, что для неориентированных графов она симметрична.

### Матрицы в R

Давайте вспомним как пользоваться матрицами в R.

#### Способы задания матриц

Для этого нам понадобится функция ‘matrix’. У неё есть 3 главных аргумента:

* `data` - то чем заполняем матрицу, это может быть число или массив.
* `nrow` - количество строк в матрице.
* `ncol` - количество столбцов в матрице.

Давайте попробуем создать матрицу, состоящую из 0 размером 3 на 4.

```{r}
matrix(data = 0, nrow = 3, ncol = 4)
```

А теперь давайте попробуем заполнить матрицу с помощью массива.

```{r}
matrix(data = 1:12, nrow = 3, ncol = 4)
```

Как видим массив заполнялся по столбцам, сначала первый, потом второй и так далее. Если вы хотите заполнить его построчно, то вы можете воспользоваться еще одним параметром `byrow`. Давайте попробуем.

```{r}
matrix(data = 1:12, nrow = 3, ncol = 4, byrow = TRUE)
```

#### Обращение к матрице и изменение ее значений

Матрица -- это двумерный массив, поэтому обращаться к ней можно так же, но при этом нужно указывать уже 2 индекса(строка и столбец). Давайте зададим случайную матрицу 4 на 5 и найдем ее значение, которое находится в 3 строчке, 4 столбце. 

```{r}
(M <- matrix(sample(-100:100, 20), nrow = 4, ncol = 5))
M[3,4]
```

Также указав один индекс мы можем получить целую строчку или целый столбец.

```{r}
M[3,]
M[,4]
```

Если мы хотим присвоить какое-то значение, то мы указываем какой элемент матрицы хотим поменять.Ставим знак присвоения и пишем новое значение. Давайте поменяем значение в 3 строчке,4 столбце матрицы `M`.

```{r}
M[3,4] <- 25
print(M)
```

### Основные функции для работы с графами

При реализации алгоритмов нам нужно будет каждый раз создавать граф, добавлять и удалять ребра. Поэтому напишем готовые функции для этого.

#### Создание графа

Чтобы создать граф достаточно создать матрицу из нулей размера `n` на `n`. 

```{r}
newGraph <- function(n){
  G <- matrix(data = 0, nrow = n, ncol = n)
  return(G)
}
```

Давайте попробуем использовать функцию. Создадим граф из 6 вершин.

```{r}
R <- newGraph(6)
print(R)
```

#### Добавление ребра

Пустой граф нам не очень интересен, поэтому нужно заполнить его ребрами. Представим, что мы работаем с неориентированным графом и нам не важен вес. Чтобы добавить ребро, нужно знать в какой граф мы хотим это сделать, а также вершины между которыми будет ребро. На выходе у нас будет обновленная матрица.

```{r}
addEdge <- function(G, i, j){
  G[i, j] <- 1
  G[j, i] <- 1
  return(G)
}
```

Добавим несколько ребер в наш граф `R`.

```{r}
R <- addEdge(R, 1, 2)
R <- addEdge(R, 2, 5)
```

У ребер бывает вес, поэтому при добавлении ребра хотелось бы иметь параметр `w`, который отвечает за вес. Улучшим нашу функцию.

```{r}
addEdge <- function(G, i, j, w = 1){
  G[i, j] <- w
  G[j, i] <- w
  return(G)
}
```

Если мы не хотим добавлять вес, то он будет по дефолту равен 1. Добавим еще ребер в граф `R`.

```{r}
R <- addEdge(R, 1, 2, 10)
R <- addEdge(R, 2, 5)
```

Граф бывает ориентированный. В этом случае мы должны поменять только 1 значение, а не 2. Введем еще один бинарный параметр `directed` для обозначения типа графа. С помощью `if` можно удостовериться в типе графа и изменить либо 1, либо 2 значения.

```{r}
addEdge <- function(G, i, j, w = 1, directed = FALSE){
  if(directed == FALSE){
    G[i, j] <- w
    G[j, i] <- w
  }else{
    G[i, j] <- w
  }
  return(G)
}
```

Давайте добавим в граф `R` ориентированое ребро из вершины 5 в вершину 6 с весом 19.

```{r}
R <- addEdge(R, 5, 6, 19, directed = TRUE)
print(R)
```

Наша функция почти идеальна, оптимизируем ее немного. Во - первых, вне зависимости от типа графа мы выполним операцию `G[i, j] <- w`. Поэтому вынесем ее за `if`. Когда `if` небольшой можно использовать функцию `ifelse`.

```{r}
addEdge <- function(G, i, j, w = 1, directed = FALSE){
  G[i, j] <- w
  ifelse(directed == FALSE, G[j, i] <- w)
  return(G)
}
```

#### Удаление ребра

Удаление ребра эквивалентно добавлению ребра с весом 0. Поэтому можно взять код оттуда и удалить переменную `w`

```{r}
removeEdge <- function(G, i, j, directed = FALSE){
  if(directed == FALSE){
    G[i, j] <- 0
    G[j, i] <- 0
  }else{
    G[i, j] <- 0
  }
  return(G)
}
```

Удалим в графе `R` недавно созданное ребро из вершины 5 в вершину 6.

```{r}
R <- removeEdge(R, 5, 6)
print(R)
```

