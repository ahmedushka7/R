---
title: "Введение в R (часть 2)"
author: "Ахмедушка"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, highlight = FALSE,eval = FALSE)
```

### Цикл for

```{r}
# Зачем нужны циклы? Представим, что вас попросили вывести на экран 
# последовательно 10 первых чисел массива. С текущими знаниями мы бы 
# сделали это следующим образом:
v <- random <- sample(x = 1:10, size = 15, replace = TRUE)
print(v[1])
print(v[2])
print(v[3])
print(v[4])
print(v[5])
print(v[6])
print(v[7])
print(v[8])
print(v[9])
print(v[10])

# Конструкция цикла for

for (variable in vector) {
  # здесь тело цикла
}

# Задача №1 (вывести 10 чисел массива с помощью цикла for)
for(i in 1:10){
  print(v[i])
}

# Задача №2 (вывести все числа массива)
n <- length(v)
for(i in 1:n){
  print(v[i])
}

# Задача №3 (есть 2 числа: a и b, нужно 
# вывести все целые числа,которые находятся между ними)
a <- 67
b <- 121
for(j in a:b){
  print(j)
}

# Задача №4 (вывести 15 нечетных чисел)
k <- 15
for(i in seq(1,k*2,2)){
  print(i)
}

# Задача №5 (сумма элементов массива)
s <- 0
for(i in 1:n){
  s <- s + v[i]
}
print(s)

# Задача №6 (факториал числа l)
# Факториал числа l = 1*2*3*...*l
f <- 1
l <- 6
for(i in 2:l){
  f <- f*i
}
print(f)

```

### Цикл while и матрицы

```{r}
# Цикл while = for + if = "бесконечный" цикл.

a <- 0
while (a<5) {
  a <- a + 1
  print(a)
}

# R может сломаться, если вы используете while неправильно.

# while(5==5){
#   print(666)
# }

# Матрицы.  

# Способы задания.

m <- matrix(data = 0, nrow = 3, ncol = 5)
print(m)

m1 <- matrix(data = 1:15, nrow = 3, ncol = 5)
print(m1)

m2 <- matrix(data = 1:15, nrow = 3, ncol = 5, byrow = TRUE)
print(m2)

# Обращение к матрицам очень похоже на обращение к массивам. Но матрица имеет 
# 2 оси.

m2[1,5]
m2[3,2]

# Элементы матрицы можно менять.

m2[1,5] <- 7

# Можно обращаться к строке или столбцу.
m2[1,] # 1 строка
m2[,2] # 2 столбец
```

### Функция

```{r}
# Предположим у нас есть 3 массива. И нам нужно найти сумму каждого из них.
# Не зная, что такое функция, мы бы сделали следующим образом:

m1 <- 1:5
m2 <- 3:6
m3 <- c(-10,0,9)

s1 <- 0
s2 <- 0
s3 <- 0

for(i in 1:length(m1)){
  s1 <- s1 + m1[i]
}

for(i in 1:length(m2)){
  s2 <- s2 + m2[i]
}

for(i in 1:length(m3)){
  s3 <- s3 + m3[i]
}

print(s1)
print(s2)
print(s3)

# Если представить, что таких массивов будет болльше или мы будем находить 
# не сумму, а что-то другое(где код будет гораздо больше),то возникает проблема: 
# код занимает очень много места, хотя производится одна и та же операция, но с разными входными данными.
# Для решения данной проблемы была придумана функция.

SUM <- function(x){
  s <- 0
  for(i in 1:length(x)){
    s <- s + x[i]
  }
  return(s)
}

SUM(m1)
SUM(m2)
SUM(m3)

# Код значительно уменьшился. Попробуем сделать функцию, которая выводит квадрат числа.
f <- function(x){
  l <- x^2
  return(l)
}

f(5)

# А теперь улучшим предыдущую фукцию. На вход будет подаваться число и строковая переменная,
# которая равна либо "Куб" , либо "Квадрат"

f <- function(x,y){
  if(y == 'Квадрат'){
    l <- x^2
    return(l)
  }else{
    l <- x^3
    return(l)
  }
}

f(3,y = 'Куб')

# У многих функций, есть дефолтные параметры. Они нужны, чтобы уменьшить написание
# входных переменных функции. 

f <- function(x,y = 'Квадрат'){
  if(y == 'Квадрат'){
    l <- x^2
    return(l)
  }else{
    l <- x^3
    return(l)
  }
}

f(2)
f(2, y = 'Куб')

# Внутри каждой функции используются какие-то дополнительные переменные. Но их значение
# используется только внутри функции, поэтому такие переменные называются локальными.
# Переменные, которые мы видим в правом верхнем окошке являются глобальными.
# Можно сделать переменную глобальной внутри функции(но лучше этого не делать)
rm(list=ls())
f <- function(x){
  l <<- x^2
  return(l)
}

f(5)

# Поработаем теперь с return. Важно, что должна выводить функция.

k <- function(x){
  a <- x*5
  b <- x/5
  c <- x+5
  return(a)
}

# Выводить можно несколько чисел, с помощью массива.

k <- function(x){
  a <- x*5
  b <- x/5
  c <- x+5
  return(с(a,b,c))
}

# Напишем функцию факториала.
fact <- function(n) {
  k <- 1
  for(i in 2:n){
    k <- k*i
  }
  return(k)
}

# Теперь поговорим про рекурсию. Рекурсия - это функция, которая использует саму себя.
fact1 <- function(n){
  if(n == 1){
    return(1)
  }else{
    k <- fact1(n-1)
    return(n*k)
  }
}


```

### Семинар

```{r}
# Задача №1
# Дано число k. Нужно вывести треугольник с изчезающим первым значением.
# Например, k = 9, тогда вывод должен быть следующим:

# 9 8 7 6 5 4 3 2 1
# 8 7 6 5 4 3 2 1
# 7 6 5 4 3 2 1
# 6 5 4 3 2 1
# 5 4 3 2 1
# 4 3 2 1
# 3 2 1
# 2 1
# 1

k <- 10



# Задача №2
# Для настольной игры используются карточки с номерами от 1 до N. Одна карточка потерялась. 
# Найдите ее, зная номера оставшихся карточек.
# Подсказка: нужно найти сумму всех карточек, а потом найти сумму известных. Дальше вычесть одно из другого.
cards <- c(1,5,7,9,2,3,4,8)





# Задача №3
# По данному натуральном n вычислите сумму 1!+2!+3!+...+n!. 
# В решении этой задачи можно использовать только один цикл.
n <- 7 
```
