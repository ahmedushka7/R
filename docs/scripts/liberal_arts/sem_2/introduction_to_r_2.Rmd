---
title: "Введение в R (часть 2)"
author: "Ахмедушка"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, highlight = FALSE,eval = FALSE)
```

### Вспоминаем прошлое занятие

В прошлый раз мы изучили основы синтаксиса R:

* обычные арифметические операции
* переменные
* массивы
* `if` (порешали задачки)

Сегодня продолжим изучать основы. 

### Цикл for

Чтобы понять зачем нужен цикл `for`, представьте, что вас попросили увеличить первые 10 значений массива. С текущими знаниями мы бы сделали это следующим образом:

```{r}
v <- random <- sample(x = 1:10, size = 15, replace = TRUE)
v
v[1] <- v[1] + 1
v[2] <- v[2] + 1
v[3] <- v[3] + 1
v[4] <- v[4] + 1
v[5] <- v[5] + 1
v[6] <- v[6] + 1
v[7] <- v[7] + 1
v[8] <- v[8] + 1
v[9] <- v[9] + 1
v[10] <- v[10] + 1
```

А вдруг нас попросили бы это сделать для 1000 значений? Для облегчения таких операций придумали цикл `for`. Можно заметить, что в наших действиях менялся только индекс массива, остальное оставалось тем же. Этот индекс можно сделать переменной и менять с помощью массива. Конструкция цикла `for` выглядит следующим образом.

```{r, eval=FALSE}
for (variable in vector) {
  # здесь тело цикла
}
```

1. Вывести 10 чисел массива с помощью цикла `for`.

```{r, echo=FALSE}
for(i in 1:10){
  print(v[i])
}
```

2. Вывести все числа массива.

```{r, echo=FALSE}
n <- length(v)
for(i in 1:n){
  print(v[i])
}
```

3. Есть 2 числа: a и b, нужно вывести все целые числа,которые находятся между ними.

```{r, echo=FALSE}
a <- 67
b <- 121
for(j in a:b){
  print(j)
}
```

4. Вывести 15 нечетных чисел(постараться сделать без `if`).

```{r, echo=FALSE}
k <- 15
for(i in seq(1,k*2,2)){
  print(i)
}
```

5. Найти сумму элементов массива.

```{r, echo=FALSE}
s <- 0
for(i in 1:n){
  s <- s + v[i]
}
print(s)
```

6. Факториал числа l. 

```{r, echo=FALSE}
f <- 1
l <- 6
for(i in 2:l){
  f <- f*i
}
print(f)
```

### Матрицы

Еще одним контейнером хранения данных являются матрицы. Это двумерный массив. Следовательно он имеет уже 2 координаты, а не 1.

Чтобы создать матрицу нужно исользовать функцию `matrix`. Она имеет следующие аргументы:

* `data` - то чем будет заполнена матрица (массив или число)
* `nrow` - количество строк
* `ncol` - количество столбцов
* `byrow` - заполнять по строкам (`TRUE`), заполнять по столбцам (`FALSE`)

```{r}
m <- matrix(data = 0, nrow = 3, ncol = 5)
print(m)

m1 <- matrix(data = 1:15, nrow = 3, ncol = 5)
print(m1)

m2 <- matrix(data = 1:15, nrow = 3, ncol = 5, byrow = TRUE)
print(m2)
```

Обращение к матрицам очень похоже на обращение к массивам. Но матрица имеет 2 оси. Чтобы выделить какой-то элемент, нужно написать нахвание матрицы, а потом в квадратных скобках через запятую указать номер строки и номер столбца.

```{r}
m2[1,5]
m2[3,2]
```

Элементы матрицы можно менять.

```{r}
m2[1,5] <- 7
```

Можно выделять отдельно столбец или строку.

```{r}
m2[1,] # 1 строка
m2[,2] # 2 столбец

```

Задача: создать матрицу произвольной размернорсти и заполнить её значение суммой номера строки и номера столбца. То есть, если элемент находится в 5 строке и 4 столбце, то его значение равно 9 (подсказка:  использовать два `for`).

```{r, echo=FALSE}
m <- matrix(data = 0, nrow = 3, ncol = 5)
for(i in 1:nrow(m)){
  for(j in 1:ncol(m)){
    m[i,j] <- i + j
  }
}
print(m)
```

### Цикл while

Мы уже изучили цикл `for`. Но часто бывает нужно совершать не какое-то фиксированное количество операций. То есть нужно совершать операцию пока какое-то условие выполняется. Для этого нужен цикл `while`. Цикл `while` = `for + if` = "бесконечный" цикл.

```{r}
a <- 0
while (a<5) {
  a <- a + 1
  print(a)
}
```

R может сломаться, если вы используете while неправильно.

```{r}
# while(5==5){
#   print(666)
# }
```

### Функции

Предположим у нас есть 3 массива. И нам нужно найти сумму каждого из них. Не зная, что такое функция, мы бы сделали следующим образом.

```{r}
m1 <- 1:5
m2 <- 3:6
m3 <- c(-10,0,9)

s1 <- 0
s2 <- 0
s3 <- 0

for(i in 1:length(m1)){
  s1 <- s1 + m1[i]
}

for(i in 1:length(m2)){
  s2 <- s2 + m2[i]
}

for(i in 1:length(m3)){
  s3 <- s3 + m3[i]
}

print(s1)
print(s2)
print(s3)
```

Если представить, что таких массивов будет болльше или мы будем находить не сумму, а что-то другое(где код будет гораздо больше),то возникает проблема: код занимает очень много места, хотя производится одна и та же операция, но с разными  входными данными. Для решения данной проблемы была придумана функция.

```{r}
SUM <- function(x){
  s <- 0
  for(i in 1:length(x)){
    s <- s + x[i]
  }
  return(s)
}

SUM(m1)
SUM(m2)
SUM(m3)
```

Код значительно уменьшился. Попробуем сделать функцию, которая выводит квадрат числа.

```{r}
f <- function(x){
  l <- x^2
  return(l)
}

f(5)
```


```{r}
# А теперь улучшим предыдущую фукцию. На вход будет подаваться число и строковая переменная,
# которая равна либо "Куб" , либо "Квадрат"

f <- function(x,y){
  if(y == 'Квадрат'){
    l <- x^2
    return(l)
  }else{
    l <- x^3
    return(l)
  }
}

f(3,y = 'Куб')

# У многих функций, есть дефолтные параметры. Они нужны, чтобы уменьшить написание
# входных переменных функции. 

f <- function(x,y = 'Квадрат'){
  if(y == 'Квадрат'){
    l <- x^2
    return(l)
  }else{
    l <- x^3
    return(l)
  }
}

f(2)
f(2, y = 'Куб')

# Внутри каждой функции используются какие-то дополнительные переменные. Но их значение
# используется только внутри функции, поэтому такие переменные называются локальными.
# Переменные, которые мы видим в правом верхнем окошке являются глобальными.
# Можно сделать переменную глобальной внутри функции(но лучше этого не делать)
rm(list=ls())
f <- function(x){
  l <<- x^2
  return(l)
}

f(5)

# Поработаем теперь с return. Важно, что должна выводить функция.

k <- function(x){
  a <- x*5
  b <- x/5
  c <- x+5
  return(a)
}

# Выводить можно несколько чисел, с помощью массива.

k <- function(x){
  a <- x*5
  b <- x/5
  c <- x+5
  return(с(a,b,c))
}

# Напишем функцию факториала.
fact <- function(n) {
  k <- 1
  for(i in 2:n){
    k <- k*i
  }
  return(k)
}

# Теперь поговорим про рекурсию. Рекурсия - это функция, которая использует саму себя.
fact1 <- function(n){
  if(n == 1){
    return(1)
  }else{
    k <- fact1(n-1)
    return(n*k)
  }
}


```

### Семинар

```{r}
# Задача №1
# Дано число k. Нужно вывести треугольник с изчезающим первым значением.
# Например, k = 9, тогда вывод должен быть следующим:

# 9 8 7 6 5 4 3 2 1
# 8 7 6 5 4 3 2 1
# 7 6 5 4 3 2 1
# 6 5 4 3 2 1
# 5 4 3 2 1
# 4 3 2 1
# 3 2 1
# 2 1
# 1

k <- 10



# Задача №2
# Для настольной игры используются карточки с номерами от 1 до N. Одна карточка потерялась. 
# Найдите ее, зная номера оставшихся карточек.
# Подсказка: нужно найти сумму всех карточек, а потом найти сумму известных. Дальше вычесть одно из другого.
cards <- c(1,5,7,9,2,3,4,8)





# Задача №3
# По данному натуральном n вычислите сумму 1!+2!+3!+...+n!. 
# В решении этой задачи можно использовать только один цикл.
n <- 7 
```


```{r}
# Задача №7. Посчитать сумму всех четных элементов массива.


# Задача №8. Есть переменная action. Она может быть равна либо "Сложить", либо "Перемножить"
# В зависимости от этой переменной нужно сложить или перемножить все элементы массива.
```


