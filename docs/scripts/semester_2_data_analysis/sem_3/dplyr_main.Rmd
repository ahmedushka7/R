---
title: "Data manipulation with dplyr"
author: "Ахмедушка"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, highlight = FALSE)
```

## Пакет dplyr и набор данных flights

На прошлом занятии мы поговорили о том, откуда можно взять данные и как их импортировать. Но почти всегда данные приходят не в том виде, в котором нам хотелось бы. Поэтому перед тем как приступать к визуализации или построению модели, нужно обработать наши данные. В этом нам поможет пакет `dplyr`, который входит в библиотеку `tidyverse`.

Мы рассмотрим основные функции этого пакета:

* `filter`
* `arrange`
* `select`
* `mutate`
* `summarize`
* `group_by`

Функции из этого пакеты мы будем использовать на датасете `flights`, который находится в пакете `nycflights13`.В этом датасете содержится информация о всех авиарейсах из аэропортов Нью-Йорка, совершенных в 2013 году. Описание датасета можно выполнив команду `?flights`.

Давайте подгрузим наши пакеты.

```{r}
# install.packages('dplyr')
# install.packages('nycflights13')
library('dplyr')
library('nycflights13')
```

Разберем каждую функцию отдельно.

## Filter

С помощью функции `filter` вы сможете отбирать наблюдения по их значениям. Первым аргументом функции является имя df(data frame). Последующие аргументы это логические выражения, которые обеспечивают отбор(фильтрацию). Давайте попробуем использовать эту функцию на практике.

```{r}
filter(flights, month == 1, day == 1)
```

Данная функция на выходе выдаёт df c авиарейсами, которые были совершены за 1 января. Наше логическое выражение строится следующим образом: выбираем название колонки и сравниваем его с какими-либо значения.  Важно отметить, что название колонок не находятся в кавычках. 

Чтобы эффективно пользоваться данной функцией, нужно вспомнить **операторы сравнения**:

* `>` - больше
* `<` - меньше
* `>=` - больше или равно
* `<=` - меньше или равно
* `==` - равно
* `!=` - не равно

Вы можете смело использовать для составления логических выражений. Помним, что один знак равно(`=`) это оператор присваивания, а два знака равно(`==`) оператор сравнения.

Функция не поменяла df `flights`. Если вы хотите запомнить результат, то вам нужно присвоить его какой-нибудь переменной.

```{r}
j1 <- filter(flights, month == 1, day == 1)
```

Помним, что при сравнении могут возникнуть некоторые проблемы, связанные с точностью.

```{r collapse=TRUE}
0.1 + 0.2 == 0.3
1/49 * 49 == 1
```

Чтобы избежать такого рода проблемы лучше использовать функцию `near` вместо `==`.

```{r collapse=TRUE}
near(0.1 + 0.2, 0.3)
near(1/49 * 49, 1)
```

Если передавать функции `filter` несколько аргументов, то мы увидим только те наблюдения, которые удовлетворяют всем условиям или другими словами используется логический оператор **И**. 

Давайте вспомним основные логические операторы:

* `И` - наблюдения, которые удовлетворяют всем условиям(`&`).
* `ИЛИ` - наблюдения, которые удовлетворяют хотя бы одному условию(`|`).
* `НЕ` - наблюдения, которые не удовлетворяют данному условию(`!`).
* `XOR` - наблюдения, которые не удовлетворяют обоим условиям, то есть дополнение к `И`(`xor()`).

**НЕЛЬЗЯ** использовать `&&` и `||`.

Посмотрим как ими можно пользоваться.

```{r}
filter(flights, month == 5 | month == 6)
```

Данный запрос выведет все авиарейсы за май и июнь. Важно понимать, что записывать запрос таким образом: `filter(flights, month == 5|6)` **НЕЛЬЗЯ**!.

Когда значений для одного столбца достаточно много, то не очень удобно записывать все это для каждого значения. На помощь приходит выражение `%in%`. Его можно использовать как в коде, так и в работе с данными. Ниже можно увидеть два одинаковых выражения, но второе намного приятнее.

```{r eval=FALSE}
filter(flights, month == 5, month == 6, month == 8, month == 12)
filter(flights, month %in% c(5, 6, 8, 12))
```

Старайтесь не создавать сложные запросы. 

```{r}
filter(flights, !(arr_delay > 120 | dep_delay > 120))
```

Данный запрос выводит все авиарейсы с зарержкой не более 2 часов(как по прибытию, так и по отправке). Запрос выглядит очень сложно. Старайтесь этого избегать. Например, если вспомнить законы де Моргана из дискретной математики, то можно его упростить.

```{r}
filter(flights, arr_delay<=120, dep_delay <= 120)
```

Важно также разобраться с отсутствующими значениями(`NA`).  Чтобы проверить является ли значение равным `NA`, нужно использовать функцию `is.na`. C помощью этой функции можно убрать наблюдения, по которым у нас нет данных.

```{r}
filter(flights, !is.na(arr_delay))
```

## Arrange

С помощью функции `arrange` вы можете сортировать ваш df. Первым аргументом функции является имя df(data frame). Последующие аргументы это названия столбцов, по которым идет сортировка.

```{r}
arrange(flights, year, month, day)
```

С помощью такого запроса мы отсортировали сначала года, потом месяцы для каждого года, а потом дни в каждом месяце. Порядок аргументов здесь очень важен. Можно убедиться на примере ниже.

```{r}
arrange(flights, month, day, year)
```

Если вы хотите отсортировать в обратном порядке, то можно использовать функцию `desc`.

```{r}
arrange(flights, desc(year))
```

Важно знать, что отсутствующие значения(`NA`) будут находиться в самом конце после сортировки.

## Select

Часто бывает, что в данных очень много переменных, но вам нужны не все. С помощью функции `select` вы сможете отбирать те переменные, которые вам нужны для дальнейшей работы. Первым аргументом функции является имя df(data frame). Последующие аргументы это переменные(название стобцов), которые вам будут нужны.

С помощью запроса ниже мы выбрали переменные:

* `year`
* `month`
* `day`

```{r}
select(flights, year, month, day)
```

А с помощью такого мы выбрали все переменные, которые находятся между `year` и `day`.

```{r}
select(flights, year:day)
```

Аналогичный запрос, но с индексами столбцов.

```{r}
select(flights, 1:3)
```

Если вы хотите увидеть все столбцы за исключением каких-то, то можно воспользоваться знаком `-`.

```{r}
select(flights, -(year:day))
```

Такие запросы можно комбинировать. Можно взять первые десять столбцов за исключением 2.

```{r}
select(flights, 1:10, -2)
```

Когда переменных очень много, то такой способ становиться неудобным. Но на помощь приходят вспомогательные функции:

* `starts_with('abc')` - отбирает столбцы, которые начинаются c *abc*.
* `ends_with('xyz')` - отбирает столбцы, которые заканчиваются на *xyz*.
* `contains('ijk')` - обирает столбцы, которые содержат последовательность символов *ijk*.
* `matches('(.)\\1')` - обирает столбцы, которые удовлетворяют *регулярному выражению*.
* `num_range("x", 1:5)` - отбирает столбцы с названием `x1`, `x2`, `x3`, `x4`, `x5`.
* `one_of(vars)` - выбирает столбцы, название которых находится в векторе `vars`. Если какого-то столбца, то выдаст предупреждение, но не ошибку(если бы мы не использовали функцию).

Давайте попробуем их применить. Допустим нам нужные данные только по прилёту.

```{r}
select(flights, contains('arr'))
```

Появился лишний столбец `carrier`, но нам уже проще работать с таким df.

Есть еще одна вспомогательная `everything()`. Она помогает перенести некоторые переменные в начало df. Это бывает удобно. Но вы хотите сохранить остальные переменные. Давайте перенесем переменные `air_time` и `time_hour` вперёд, а остальные переменные пойдут за ними.


```{r}
select(flights, air_time, time_hour, everything())
```

С помощью функции `select` можно переименовать переменные, но при этом останутся только те переменные, которые вы переименовали.

```{r}
select(flights, Год = year)
```

Для того, чтобы переименовать какой-то столбец, но оставить все остальные, можно использовать функцию `rename`.

```{r}
rename(flights, Год = year)
```

## Mutate

С помощью функции `select` вы сможете создавать новые переменные, основанные на уже существующих. Первым аргументом функции является df. Последующие аргументы выглядят следующим образом:

> название новой переменной = операции с существующими переменными

Новые переменные добавляются в конец df. Поэтому давайте уменьшим наш df, чтобы мы могли увидеть новые переменные.

```{r}
flights_sml <- select(flights, year:day,
                               distance,
                               air_time)
```

Давайте создадим переменную `speed`. Она будет показывать среднюю скорость самолёта.

```{r}
mutate(flights_sml, speed_ml = distance / air_time * 60)
```

Умножаем на 60, так как время дано в минутах. Данная скорость выражена мили/час. На только что созданные перменные можно сразу же ссылаться. Давайте найдем скорость км/час.

```{r}
mutate(flights_sml, speed_ml = distance / air_time * 60,
                    speed_km = speed_ml * 1.61)
```

Если вы хотите выделить только те переменные, которые только создали вы можете использовать функцию `transmute`.

```{r}
transmute(flights_sml, speed_ml = distance / air_time * 60,
                    speed_km = speed_ml * 1.61)
```




рассказать про pipe(%>%)

## Group_by and summarize









Рассказать про регулярные выражения.

two <- c("AA", "AS")
lut <- c("AA" = "American", 
         "AS" = "Alaska", 
         "B6" = "JetBlue")
two <- lut[two]
two
