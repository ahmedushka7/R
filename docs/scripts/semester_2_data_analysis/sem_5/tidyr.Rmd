---
title: "Аккуратизация данных с помощью пакета tidyr"
author: "Ахмедушка"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, highlight = FALSE)
```

```{r}
library('tidyr')
library('tibble')
library('dplyr')
```


### recap
вспомнить про основные функции с df
as.numeric
lubridate и stringr(в отдельном файле)

```{r}
table1
table2
table3

table4a  # cases
table4b  # population
```

### Фунция gather

Функция `gather` имеет 4 аргумента:

* `df` - дата фрейм
* `key` - название нового столбца ключей
* `value` - название нового столбаца значения
* `...` - название столбцов, которые должны быть задействованы или наоборот не задействованы

```{r}
table4b %>% 
  gather(`1999`, `2000`, key = "year", value = "population")
```

![](https://github.com/hadley/r4ds/blob/master/images/tidy-9.png?raw=true)

### Функция spread

Функция `spread` имеет 3 аргумента:

* `df` - дата фрейм
* `key` - название столбца, который содержит ключи
* `value` - название столбаца, который содержит значения

```{r}
table2 %>%
    spread(key = type, value = count)
```

![](https://github.com/hadley/r4ds/blob/master/images/tidy-8.png?raw=true)

### Функция separate

Функция `separate` имеет 4 аргумента:

* `df` - дата фрейм
* `col` - название столбца, который нужно будет разделить
* `into` - название новых столбцов(в виде массива)
* `sep` - тип разделителя

```{r}
table3
```

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"))
```

![](https://github.com/hadley/r4ds/blob/master/images/tidy-17.png?raw=true)

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), sep = "/")
```


```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), convert = TRUE)
```

```{r}
table3 %>% 
  separate(year, into = c("century", "year"), sep = 2)
```


### Функция unite

Функция `unite` выполняет действие обратное функции `separate`. Она объединяет несколько столбцов в один столбец.

Функция `separate` имеет 4 аргумента:

* `df` - дата фрейм
* `col` - название новго столбца
* `...` - название столбцов, которые нужно объединить
* `sep` - тип соединения

```{r}
table5
```

```{r}
table5 %>% 
  unite(new, century, year)
```

про sep

```{r}
table5 %>% 
  unite(new, century, year, sep = "")
```

![](https://github.com/hadley/r4ds/blob/master/images/tidy-18.png?raw=true)

### Отсутсвующие значения

```{r}
df <- tibble(A = c(1,NA,2,3),
             B = c(NA,7,10,32),
             C = c(55,42,NA,0))
df
```

Функция `is.na`

```{r}
is.na(df)
```

```{r}
any(is.na(df))
```

```{r}
sum(is.na(df))
```

```{r}
which(is.na(df$A))
```


```{r}
summary(df)
```

Найти строки, у которых отсутсвтвует значение `NA`.

```{r}
complete.cases(df)
```

```{r}
df[complete.cases(df),]
```

Есть еще способы

```{r}
na.omit(df)
```

```{r}
df %>% drop_na()
```

### Выбросы

Рассказать про set.seed

выбосы
например отрицательные числа для переменной количество лет

```{r}
set.seed(10)
x <- c(rnorm(30,mean=15,sd=5), -5, 28, 35)
boxplot(x, horizontal = TRUE)
```

ящик с усами
жирная медиана
25 и 75 процентиль
концы это края это статистически значимой выборки
можно boxplot(df)

визуально через гистограмму, рисунок или summar

про quantile и 

### Применяем знания

```{r}
weather2 <- gather(weather, day, value, paste0('X',1:31), na.rm = TRUE)
# First remove column of row names
without_x <- weather2[, -1]

# Spread the data
weather3 <- spread(without_x, measure, value)

# View the head
head(weather3)

# Load the stringr and lubridate packages
library('stringr')
library('lubridate')

# Remove X's from day column
weather3$day <- str_replace(weather3$day,'X','')

# Unite the year, month, and day columns
weather4 <- unite(weather3, date, year, month, day, sep = "-")

# Convert date column to proper date format using lubridates's ymd()
weather4$date <- ymd(weather4$date)

# Rearrange columns using dplyr's select()
weather5 <- select(weather4, date, Events, CloudCover:WindDirDegrees)

# View the head of weather5
head(weather5)

as.numeric(weather5$PrecipitationIn)

# Replace "T" with "0" (T = trace)
weather5$PrecipitationIn <- str_replace(weather5$PrecipitationIn, 'T','0')

# Convert characters to numerics
weather6 <- mutate_at(weather5, vars(CloudCover:WindDirDegrees), funs(as.numeric))

# Look at result
str(weather6)

# Count missing values
sum(is.na(weather6))

# Find missing values
summary(weather6)

# Find indices of NAs in Max.Gust.SpeedMPH
ind <- which(is.na(weather6$Max.Gust.SpeedMPH))

# Look at the full rows for records missing Max.Gust.SpeedMPH
weather6[ind, ]

# Review distributions for all variables
summary(weather6)

# Find row with Max.Humidity of 1000
ind <- which(weather6$Max.Humidity == 1000)

# Look at the data for that day
weather6[ind, ]

# Change 1000 to 100
weather6$Max.Humidity[ind] <- 100

# Look at summary of Mean.VisibilityMiles
summary(weather6$Mean.VisibilityMiles)

# Get index of row with -1 value
ind <- which(weather6$Mean.VisibilityMiles == -1)

# Look at full row
weather6[ind,]

# Set Mean.VisibilityMiles to the appropriate value
weather6$Mean.VisibilityMiles[ind] <- 10

new_columns <- c("date", "events", "cloud_cover", "max_dew_point_f", "max_gust_speed_mph", 
"max_humidity", "max_sea_level_pressure_in", "max_temperature_f", 
"max_visibility_miles", "max_wind_speed_mph", "mean_humidity", 
"mean_sea_level_pressure_in", "mean_temperature_f", "mean_visibility_miles", 
"mean_wind_speed_mph", "mean_dew_point_f", "min_dew_point_f", 
"min_humidity", "min_sea_level_pressure_in", "min_temperature_f", 
"min_visibility_miles", "precipitation_in", "wind_dir_degrees"
)

# Clean up column names
names(weather6) <- new_colnames

# Replace empty cells in events column
weather6$events[weather6$events == ""] <- 'None'
    
# Print the first 6 rows of weather6
head(weather6)
```

