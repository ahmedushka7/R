---
title: "Импорт данных"
author: "Ахмедушка"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    highlight: pygments
  # df_print: paged
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Ликбез по директории

Директория - это место(папка), где находится ваш "проект". То есть там лежит скрипт, данные, картинки и так далее. Когда вы хотите загрузить данные с файлика, вам нужно прописать путь к нему, но если он находится в вашей директории, то можно просто напиать его название.

После подгрузки всех необходимых пакетов, нужно узнать в какой директории вы находитесь. Это можно сделать с помощью функцию `getwd()`.

Зачастую импользуется много разных папок под каждый "проект", поэтому приходится часто менять директорию. Есть два способа это сделать:

1. Использовать функция `setwd("C:/My Documents")`, где в кавычках можно прописать путь к директории.
2. На панели R нажать кнопку *Session* и в выпадающем списке выбрать *Set Working Directory*. После чего вы можете выбрать нужную папку.

Я рекомендую именно второй способ, потому что он быстрее , и вам не нужно знать путь. Чтобы проверить, что вы находитесь в нужной директории можно использовать функцию `dir()`. Она показывает все объекты которые находятся в директории. 

## Импорт данных

Импорт данных - создание переменной, в которой будут храниться ваши данные. Важно понимать откуда мы берём данные. Обычно источником импорта выступают:

1. Обычные файлы(csv, txt)
2. Excel
3. Базы данных(SQL)
4. Интернет

Мы поговорим про первые 2 типа. Есть различные пакеты для связи R с SQL. Выкачивание данных из интернета называется парсинг(скрапинг).Парсить данные можно с помощью R, но все таки для этого лучше подойдёт Python.

## Импорт файлов с расширениями csv, txt и другими

### Функция read.csv()

Формат csv самый распространенный формат хранения данных в мире. Его можно получить,например, сохранив excel файл в формате csv(разделитель - запятая). Перед тем как подгружать файл, нужно открыть файл в текстовом редакторе и посмотреть его структуру. Ну обратить внимание на:

1. Наличие шапки(то есть имеются ли названия столбцов)
2. Тип разделителя(чем отделены друг от друга переменные)

Советую, если вы часто работаете в разных директориях, прописать путь к файлу в отдельную переменную path. Есть функция `file.path(‘~’, ‘data’, ‘data.csv’)`, но все таки лучше копировать путь из свойств файла. Также важно отметить про то, что Windows ставит слэш в обратную сторону. 

\[
read.csv(path,\ header = TRUE,\ sep =\ ","\ ,\ stringAsFactors = TRUE,\ dec =\ '.\ ')
\]

Параметры(их дефолтное значение):

1. path - путь к файлу
2. header(TRUE) - есть ли в файле наименования столбцов
3. sep(',') - разделитель
4. stringAsFactors - сделать ли столбец строковых переменных в факторный
5. dec - для числовых переменных (точка или запятая)
6. col.names - можно передать массив с названиями переменных

Это основные параметры, остальные можно посмотреть с помощью `help(read.csv)` или `?read.csv`.

#### Попытка №1

А давайте просто укажем файл и забьем на все эти параметры.

```{r}
data <- read.csv('file_csv.csv')
data
```

R неправильно прочитал файл. Он думает, что у нас есть всего два столбца. Почему так вышло? Если открыть файл в текстовом редакторе, то можно увидеть, что разделителем является **;**.

#### Попытка №2

Теперь мы поняли свою ошибку. Давайте её исправим

```{r}
data <- read.csv('file_csv.csv', sep = ';')
data
```

Ой! Первая строчка стала названием столбцом. Почему так вышло?

#### Попытка №3

Исправим еще одну ошибку.

```{r}
data <- read.csv('file_csv.csv', sep = ';', header = FALSE)
data
```

Если взглянуть на данные, то кажется, что всё прекрасно. Но это не так! Что не нравится вам?(Поможет функция `str`)

1. Попробуйте вытащить любое число и провести с ним какую-нибудь операцию.
2. Данные без названия столбцов - это не данные.
3. Хотелось бы, чтобы не было факторных переменных.

#### Попытка №4

Попробуем сделать всё так, как нужно!

```{r}
data <- read.csv('file_csv.csv', sep = ';', header = FALSE, dec = ',', stringsAsFactors = FALSE, col.names = c('Имя', 'Возраст', 'Пол', 'Рандомное число'))
data
```

Иногда бывают данные, где столбец это год. Например у вас есть временной ряд за 1960 - 1976 года. Писать название каждого столбца утомительно. Можно воспользоваться функцией `paste0`.

```{r}
paste0("year_", 1960:1976)
```

Помним, что обычный `data.frame` не терпит пробелов в названии переменной. Можно ставить нижнее подчеркивание(_).

### Функция read.delim() и read.table()

Нужно сказать сначала то, что функции `read.delim` и `read.csv` это дочерние функции от `read.table`. Как мы уже убедились `read.csv` создан для файлов с расширением csv. А вот `read.delim` создан для файлов с расширением *txt*. Если у вас есть какое-то другое расширение, то вы можете использовать `read.table` с нужными вам параметрами.

#### Функция read.dellim()

**/t** - знак табуляции (один из видов разделителей). В `read.delim` он используется по умолчанию.

```{r}
data <- read.delim('file_txt.txt', dec = ',', header = FALSE, stringsAsFactors = FALSE, col.names = c('Имя', 'Возраст', 'Пол', 'Рандомное_число'))
data
```

#### Функция read.table()

Если открыть файл `file.txt` можно увидеть, что разделитель это слэш. С помощью `read.table` мы можем задать нужный нам разделитель.

```{r}
data <- read.table('file.txt', sep = '/', dec = ',', header = FALSE, stringsAsFactors = FALSE, col.names = c('Имя', 'Возраст', 'Пол', 'Рандомное_число'))
data
```

На самом деле есть еще функции `read.csv2` и `read.delim2`. Они отличаются типом разделителя или *dec*.

## Пакет readr

Сначала установим и прочитаем пакет:
```{r}
#install.packages('readr')
library('readr')
```

Зачем нам вообще этот пакет, ведь мы умеем читать файлы с расширением csv, txt и так далее. 

Плюсы:

1. Работают быстрее(примерно в 10 раз).
2. Создают tibble-frame, а не data frame.
3. Более оптимален. С ним будет меньше проблем.
4. Имеет интерактивную полосу, чтобы понимать, сколько нам еще ждать.
5. Сами могут определять тип столбца

Здесь важно использовать определенную функцию для определенного разделителя.

Изучим 2 новые опции:

1. *comment* - знак комментария в файле
2. *skip* - количество строк, которые нужно пропустить

```{r}
data <- read_csv2('file_csv_2.csv', comment = '#', col_names = c('Имя', 'Возраст', 'Пол', 'Рандомное_число'))
```

Или можно просто пропустить 1 строку.

```{r}
data <- read_csv2('file_csv_2.csv', skip = 1, col_names = c('Имя', 'Возраст', 'Пол', 'Рандомное_число'))
```

Функции этого пакета определяют тип переменных в столбце следующим образом: они берут первые 1000 наблюдений и используют к нему функцию `guess_parser`, которая определяет к какому типу относиться переменная. В больших файлах иногда бывают проблемы. Например первые 1000 значений `NA`. А с 1001 идут вещественные числа, но столбцу дадут тип `logical`. Можно увеличить количество значеий с помощью параметра `guess_max`.

Давайте проверим сокрость этого пакета. С помощью функции `Sys.time()` будем измерять время загрузки файла. Будем использовать файл под названием *nir* с расширением *csv*. Весит этот файл 50 мегабайт. Это средний размер файла, но уже здесь мы почувствуем разницу.

Посчитаем время использования функции read.csv():

```{r}
start <- Sys.time()
data <- read.csv('nir.csv')
finish <- Sys.time()

print(finish-start)
```

Видим приблизительно `r round(print(finish-start),2)` секунды. Представьте, что вы меняете и запускаете код постоянно. Хотелось бы, чтобы загрузка занимала меньше времени.

Теперь посчитаем время использования аналогичной функции `read_csv` из пакета readr:

```{r}
start <- Sys.time()
data <- read_csv2('nir.csv')
finish <- Sys.time()

print(finish-start)
```

Время уменьшилось до `r round(print(finish-start),2)` секунд!

Можно увидеть, что появились предупреждения. Это связано с проблемой описанной выше. Эту проблему можн исправить с помощью парметра `col_types`.

```{r}
data <- read_csv2('nir.csv', col_types = cols(
                                YLD_YTM_MID = col_double() ,
                                YLD_CNV_MID = col_double()
                  ))
```

## Работа с файлами Excel

Многие пакеты в R взаимодействуют с Microsoft Excel.

### Пакет readxl

Для начала установим и загрузим пакет `readxl`.

```{r}
#install.packages('readxl')
library('readxl')
```

Рассмотрим 2 функции в этом пакете:

1. `excel_sheets`
2. `read_excel`

#### Функция excel_sheets()

Пропишем один раз путь к файлу для удобства:

```{r}
path = '/home/ahmedushka/GitHub/R/docs/scripts/semester_2_data_analysis/sem_2/exchange_rate.xlsx'
```

У функции excel_sheets() на вход идёт один аргумент: путь к файлу. Если файл находится в директории, то его название.

\[
excel\_sheets("data.xlsx"")
\]

Данная функция показывает нам какие листы есть в нашем excel файле. Это очень удобно: поонять структуру excel файла.

```{r}
excel_sheets(path)
```

#### Функция read_excel()

У этой функции есть 1 обязательный аргумент: путь к файлу. Посмотрим, что сделает функция, когда у нас имеется 2 листа.

\[
data <- read\_excel("data.xlsx", sheet = "my\_sheet")
\]


```{r}
data_1 <- read_excel(path)
head(data_1)
```

Как мы видим данная функция импортировала нам только 1-ый лист. Чтобы подгрузить какой-то другой лист используем необязательный аргумент sheet.

```{r}
data_2 <- read_excel(path, sheet = 2)
head(data_2)
data_2 <- read_excel(path, sheet = "EUR")
head(data_2)
```

Чтобы удобно хранить все листы в одном месте, можно использовать функцию `list`:

```{r}
data <- list(data_1, data_2)
str(data)
```

#### Комбинируем функции excel_sheets() и read_excel() с помощью lapply()

Представьте, что у вас есть файл, в котором 10 листов. Писать 10 строчек с подгрузкой каждого листа это нудно. Но у нас есть функция `lapply`!

```{r}
data <- lapply(excel_sheets(path), read_excel, path = path)
str(data)
```

#### Более детально разберёмся с read_excel()
На самом деле у функции `read_excel` есть и другие аргументы:

\[
data <- read\_excel("data.xlsx", sheet = "my\_sheet", col_names = TRUE, col_types = NULL, skip = 0)
\]

1. `col_names` - есть ли названия столбцов в excel файле (попробовать поставить `FALSE`) или можно сразу их задавать `col_names = c('Name', 'Population')`.
2. `col_types` - можем вручную задавать тип переменных в столбце(например: `col_types('text', 'text')`.
3. `skip` - пропускает какое-то количество строк. Если используем, то нужно указать название столбцов или `FALSE`.

### Пакет gdata

Для начала подгрузим пакет:

```{r}
#install.packages('gdata')
library('gdata')
```

#### Функция read.xls()

Схемка как это работает через read.csv()

Файл с расширением *.xls — это формат всех файлов версии Excel 2003 и раньше. Он имеет меньше возможностей, работает медленнее.

Файл с расширением *.xlsx — это формат подавляющего большинства файлов Excel на настоящий момент, используется начиная с версии Microsoft Office 2007.

```{r}
data <- read.xls(path)
```

Работает через read.csv , следовательно параметры такие же как и там:

```{r}
data <- read.xls(path, sheet = 2,
                      skip = 50, header = FALSE, stringsAsFactors = FALSE,
                      col.names = c('Date', 'USD/RUB'))
```

## Пакет XLConnect

Особенности пакета:

1. Работа в excel через R.
2. Мост между R и excel.
3. Поддержка xls и xlsx.
4. Простой функционал
5. Можно записывать формулы Excel.

Чтобы пользоваться возможностями данного пакета, нужно уставновить [Java](https://www.java.com/en/download/manual.jsp).

```{r , include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```

Установим пакет:
```{r}
# install.packages("XLConnect")
library("XLConnect")
```

### Функция loadWorkbook()

Эта функция создаёт "мост" между файлом Excel и R.

```{r}
book <- loadWorkbook(path)
str(book)
print(class(book))
```

### Функция getSheets()

Показывает список листов в файле.

```{r}
getSheets(book)
```

### Функция readWorksheet

Импортирует определенный лист

```{r}
readWorksheet(book, sheet = 2)
```

Краткая инструкция:

```{r}
my_book <- loadWorkbook("urbanpop.xlsx")
sheets <- getSheets(my_book)
all <- lapply(sheets, readWorksheet, object = my_book)
str(all)
# startCol и endCol:(ПОДГРУЗКА ОПРЕДЕЛЕННЫХ СТОЛБЦОВ)
urbanpop_sel <- readWorksheet(my_book, sheet = 2, startCol = 3, endCol = 5)
```

### Изменение листов

Предположим у нас есть новые данные. Пусть пока будет cars.

### Функция createSheet()

Создаем лист в нашем файле Excel:

```{r}
book <- loadWorkbook(path)
createSheet(book, name = 'cars')
```

### Функция writeWorksheet()

Заполняет наш лист.

```{r}
book <- loadWorkbook(path)
createSheet(book, name = 'cars')
writeWorksheet(book, cars, sheet = "cars")
```

### Функция saveWorkbook()

Сохраняет наши изменения:

```{r}
book <- loadWorkbook(path)
createSheet(book, name = 'cars')
writeWorksheet(book, cars, sheet = "cars")
saveWorkbook(book, file = "exchange_rate2.xlsx")
```

### Функция renameSheet()

Меняет название листов в Excel:

```{r}
renameSheet(book, 'cars', 'Данные о машинках')
saveWorkbook(book, file = "exchange_rate3.xlsx")
```

### Функция removeSheet()

Удаляет лист в Excel:

```{r}
removeSheet(book, sheet = 'Данные о машинках')
saveWorkbook(book, file = "exchange_rate4.xlsx")
```

## Еще немного пакетов для импорта

1. `data.table` - функция `fread` еще быстрее пакета `readr`.
2. `haven` - читает файлы приложений SPSS, Stata и SAS.
3. `DBI` - позволяет взаимодействовать с базами данных.
4. `jsonlite` - для работы с форматом JSON.
5. `xml` - для работы с форматом XML.
6. `rio` - для работы с другими типами файлов.
