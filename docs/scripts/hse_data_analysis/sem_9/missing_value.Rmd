---
title: "Работа с пропущенными значениями"
author: "Зарманбетов Ахмед"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
    highlight: pygments
    #df_print: paged
editor_options: 
  chunk_output_type: console
---
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

### Пропущенные значения

С самого первого занятия мы с вами говорили про пропущенные значения. В R они отображаются как `NA`. В реальных данных часто приходится сталкиваться с ними. Например, если проводить опрос людей, то некоторые не захотят говорить о своей заработной плате. Это и есть пропущенное значение. 

### Базовая работа с пропущенными значениями

Мы уже знаем функцию `is.na`. Она выдает логический ответ на вопрос: "Является ли значение пропущенным?". Она может работать с массивами.

```{r}
x <- c(1, NA, 3, NA, NA, 5)
is.na(x)
```

Но есть и другие инструменты. Они находятся в пакете `naniar`. Давайте установим и подгрузим его и остальные пакеты.

```{r}
# install.packages("naniar")
library(naniar)
library(tidyr)
library(dplyr)
```

Наши переменные в наборе данных это массивы. И всегда хочется узнать, есть ли пропущенные значения в этой переменной. Для этого можно использовать функцию `any_na`. Она выдает логический ответ на вопрос: "Есть ли в массиве пропущенные значения?"

```{r}
any_na(x) 
y <- 1:5
any_na(y)
```

Если пропущенные значения есть, то хотелось бы знать их количество, а лучше долю.

```{r}
n_miss(x) 
prop_miss(x)
```

`NaN` считается пропущенным значением, а бесконечность `Inf` не считается. 

```{r}
any_na(NaN)
any_na(Inf)
```

Я написал функции для генерации массива с пропущенными значениями. Будем ей пользоваться.

```{r}
generate <- function(prop_na, len = 1000){
  x <- round(seq(-100, 100, length.out = len), 4)
  n <- length(x)
  y <- sample(c(NA, x), size = len, replace = TRUE, prob = c(prop_na, rep((1-prop_na)/n, n)))
  return(y)
}
```

Сгенерим набор данных с 3 переменными.

```{r}
df <- tibble(x = generate(0.05),
             y = generate(0.07),
             z = generate(0.02))
```

С помощью функции `n_miss` можно узнать количество пропущенных значений во всем наборе данных или в отдельной переменной.

```{r}
n_miss(df)
n_miss(df$x)
```

Обратная функция `n_complete` показывает сколько значений у нас есть о всем наборе данных или в отдельной переменной.

```{r}
n_complete(df)
n_complete(df$x)
```

И функция `prop_miss` и `prop_complete`, которая показывает долю пропущенных и имеющихся значений.

```{r}
prop_miss(df)
prop_complete(df)

prop_miss(df$x)
prop_complete(df$x)
```


### Различные статистики для пропущенных значений

```{r}
miss_var_summary(airquality)
miss_case_summary(airquality) # по наблюдениям

airquality %>% group_by(Month) %>% miss_var_summary()
airquality %>% group_by(Month) %>% miss_case_summary()
```

```{r}
miss_var_table(airquality)
miss_case_table(airquality)

airquality %>% group_by(Month) %>% miss_var_table()
airquality %>% group_by(Month) %>% miss_case_table()
```


Miss_var_span () вычисляет количество пропущенных значений в указанной переменной для повторяющегося диапазона. Это действительно полезно для данных временных рядов, чтобы искать еженедельные (7 дней) закономерности отсутствия

Функция miss_var_run () вычисляет количество «прогонов» или «полос» пропущенных. Это полезно, чтобы найти необычные паттерны пропусков, например, вы можете найти повторяющийся паттерн из 5 полных и 5 пропущенных.

```{r}
# Calculate the summaries for each run of missingness for the variable, hourly_counts
miss_var_run(pedestrian, var = hourly_counts)

# Calculate the summaries for each span of missingness, for a span of 4000, for the variable hourly_counts
miss_var_span(pedestrian, var = hourly_counts, span_every = 4000)

# For each `month` variable, calculate the run of missingness for hourly_counts
pedestrian %>% group_by(month) %>% miss_var_run(var = hourly_counts)

# For each `month` variable, calculate the span of missingness of a span of 2000, for the variable hourly_counts
pedestrian %>% group_by(month) %>% miss_var_span(var = hourly_counts, span_every = 2000)
```

### Визуализация пропущенных значений

#### vis_miss

```{r}
vis_miss(airquality)
vis_miss(airquality, cluster = TRUE)
```

```{r}
# Visualize all of the missingness in the `riskfactors`  dataset
vis_miss(riskfactors)

# Visualize and cluster all of the missingness in the `riskfactors` dataset
vis_miss(riskfactors, cluster = TRUE)

# visualise and sort the columns by missingness in the `riskfactors` dataset
vis_miss(riskfactors, sort = TRUE)
```

#### gg_miss_var and gg_miss_case

```{r}
gg_miss_var(airquality)
gg_miss_case(airquality)
```

```{r}
gg_miss_var(airquality, facet = Month)
```

```{r}
# Visualize the number of missings in cases using `gg_miss_case()`
gg_miss_case(riskfactors)

# Explore the number of missings in cases using `gg_miss_case()` and facet by the variable `education`
gg_miss_case(riskfactors, facet = education)

# Visualize the number of missings in variables using `gg_miss_var()`
gg_miss_var(riskfactors)

# Explore the number of missings in variables using `gg_miss_var()` and facet by the variable `education`
gg_miss_var(riskfactors, facet = education)
```

#### gg_miss_upset, gg_miss_fct and gg_miss_span

```{r}
gg_miss_upset(airquality)
```

```{r}
gg_miss_fct(x = airquality, fct = Month)
```

```{r}
gg_miss_span(pedestrian, hourly_counts, span_every = 3000)
```

```{r}
# Using the airquality dataset, explore the missingness pattern using gg_miss_upset()
gg_miss_upset(airquality)

# With the riskfactors dataset, explore how the missingness changes across the marital variable using gg_miss_fct()
gg_miss_fct(x = riskfactors, fct = marital)

# Using the pedestrian dataset, explore how the missingness of hourly_counts changes over a span of 3000 
gg_miss_span(pedestrian, var = hourly_counts, span_every = 3000)

# Using the pedestrian dataset, explore the impact of month by facetting by month
# and explore how missingness changes for a span of 1000
gg_miss_span(pedestrian, var = hourly_counts , span_every = 1000, facet = month)
```


### Что делать с пропущенными значениями

Рассмотрим разные случаи при работе с пропущенными значениями. 

#### Cлучай №1

Сгенерим набор данных, в котором будет один столбец иметь много пропущенных значений.

```{r}
df <- tibble(x = generate(0),
             y = generate(0),
             z = generate(0.7))

```

C помощью функции `miss_var_summary` и `vis_miss` посмотрим какие переменные имеют пропущенные значения.

```{r}
miss_var_summary(df)
vis_miss(df, cluster = TRUE)
```

Видно, что в переменной `z` 70.2% значений пропущены. В таких ситуациях лучше удалить всю такую переменную.

```{r}
df <- df %>%
        select(-z)
```

#### Cлучай №2

Сгенерим набор данных, в котором будет небольшое количество пропущенных значений во всех переменных.

```{r}
df <- tibble(x = generate(0.05),
             y = generate(0.07),
             z = generate(0.02))
```

C помощью функции `miss_var_summary` и `vis_miss` посмотрим какие переменные имеют пропущенные значения.

```{r}
miss_var_summary(df)
vis_miss(df, cluster = TRUE)
```

В данному случае удалять переменные не логично. Можно удалить переменные, которые содержат пропущенные значения. Найдем количество таких наблюдений с помощью функции `miss_case_summary`.

```{r}
miss_case_summary(df) %>%
  filter(n_miss > 0) %>%
  count()
```

Таких наблюдений 131. Удалим их все с помощью  функции `drop_na` из пакета `dplyr`.

```{r}
df <- df %>%
        drop_na()
```

#### Cлучай №3

В прошлом случае


#### Замена средним

```{r}
df <- tibble(x = generate(0.5, 10),
             y = generate(0.3, 10))
df

df$x %>% mean(na.rm = TRUE)
df$x %>% impute_mean()
df %>% impute_mean_if(is.numeric)
df %>% impute_mean_at('x')
df %>% impute_mean_all()
```

#### Замена медианой

```{r}
df$x %>% median(na.rm = TRUE)
df$x %>% impute_median()
df %>% impute_median_if(is.numeric)
df %>% impute_median_at('x')
df %>% impute_median_all()
```


```{r}
df %>%
  bind_shadow() %>%
  impute_mean_all
```



```{r}
df %>%
  add_label_missings('y', missing = 1,
                        complete = 0)
```

```{r}
ImputeInd <- function(df, strategy = 'mean', column){
  if (strategy == 'mean') {
    df1 <- df %>% 
      add_label_missings(y, missing = 1,
                         complete = 0) %>%
      rename_at(vars(any_missing), funs(paste0(column, '_IND', sep = ''))) %>%
      impute_mean_at('x')
    return(df1)
  }
  if (strategy == 'median') {
    df1 <- df %>% 
      add_label_missings(y, missing = 1,
                         complete = 0) %>%
      rename_at(vars(any_missing), funs(paste0(column, '_IND', sep = ''))) %>%
      impute_median_at('x')
    return(df1)
  }
  stop('Введите правильно стратегию!')
}

df %>%
  ImputeInd(strategy = 'mean', 'x')

```


про `impute_lm` 


### Еще 


  Функция complete.cases() выдает логический вектор, где TRUE означает полностью заполненную строку, а FALSE - содержащую пропуски (NAs).
sum(complete.cases(dat))
dat[!complete.cases(dat), ]
 удаляем строки, содержащие NA
dat <- na.omit(dat)
---
Для дальнейшей работы с пропущенными значениями нам понадобятся дополнительные библиотеки. Установим их. Можно устанавливать сразу несколько библиотек – оформить перечень необходимых библиотек в виде вектора, и тогда сразу после установки одной библиотеки начнется загрузка следующей.


Обратимся к ним:

```{r}
install.packages(c("mice", "VIM"))
library(mice)
library(VIM)
```


Выведем графики, которые покажут, в каких переменных пропущенных значений больше всего и как выглядит таблица с пропущенными значениями (паттерны пропущенных значений).

На графике слева показано, с какой частотой встречаются пропущенные значения в той или иной переменной. На графике справа показано, в каких комбинациях эти пропущенные значения встречаются. Например, в нашем случае отсутствие ответов в AgeOfStore часто совпадает с отсутствием ответов в SalesInThousands (пропущенные значения отмечены красным цветом).

aggr - из библиотеки mice
aggr(dat)

Следующий график отвечает за заполненность наблюдений (красным цветом отмечены пропущенные значения, остальное - заполненные значения, чем темнее цвет, тем больше значение). По вертикальной оси - номер строки в базе данных (id наблюдения).

matrixplot - из библиотеки VIM
matrixplot(dat) 



Также стоит обратить внимание на следующие ло

```{r}
NA | TRUE
NA | FALSE
```



Функции complete and fill в tidyr для работы с пропущенными значениями