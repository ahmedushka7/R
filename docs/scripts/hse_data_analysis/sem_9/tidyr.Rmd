---
title: "Аккуратизация данных с помощью пакета tidyr и работа с пропущенными значениями"
author: "Зарманбетов Ахмед"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
    highlight: pygments
    #df_print: paged
editor_options: 
  chunk_output_type: console
---
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

### Пакет tidyr
 
Данные зачастую бывают не в том виде, в котором нам нужно. Мы уже преобразовывали данные с помощью пакета `dplyr`, а теперь познакомися с пакетом `tidyr`. Подгрузим уже известные нам пакеты и пакет `tydir`.

```{r}
library('tibble')
library('dplyr')
library('lubridate')
library('readr')
library('tidyr')
```

<center>
![](pictures/tidyr.png)
</center>

Внутри пакета `tidyr` встроены некоторые небольшие датасеты. Можно вызвать справку по этим наборам данных с помощью команды `?table1`. В этих наборах данных показано число случаев заболевания туберкулезом, зарегистрированных всемирной организацией здравоохранения в Афганистане, Бразилии и Китае в период с 1999 по 2000 годы. Переменная `cases` показывает количество случаев, а переменная `population` численность населения.

Давайте посмотрим на эти наборы данных и разберёмся, что с ними не так.

В наборе данных `table2` переменная `type` содержит `cases` или `population`, а в переменной `count` соотвествующее значени. Так получается, что в переменной находятся другие переменные.

```{r}
table2
```

В наборе данных `table3` перtменная `rate` содержит две переменные, разделенные через слэш.

```{r}
table3
```

В наборах данных `table4a` и `table4b` информация о случаях и численности расположена в разных наборах данных, а также каждый год это отдельная переменная.

```{r}
table4a  # cases
table4b  # population
```

В наборах данных `table5` есть две переменные `century` и `year`, хотя хотелось бы иметь одну переменную.

```{r}
table5
```

Набор данных `table1` является эталоном.

```{r}
table1
```

### Фунция gather

В наборе данных `table4a` каждый год это отдельная переменная. Хотя год должен быть одной перменной. Привести набор данных к нужному виду поможет функция `gather`.

Функция `gather` имеет 4 аргумента:

* `df` -- дата фрейм
* `key` -- название нового столбца ключей
* `value` -- название нового столбца значений
* `...` -- название столбцов, которые должны быть задействованы или наоборот не задействованы

Используем эту функцию в двух вариантах.

```{r}
table4a %>% 
  gather(key = "year", value = "cases", `1999`, `2000`)
```

```{r}
table4a %>% 
  gather(key = "year", value = "cases", -country)
```

![](pictures/gather.png)

### Функция spread

В наборе данных `table2` переменная `type` содержит название других переменных, а в переменной `count` содержатся их значения. Привести набор данных к нужному виду поможет функция `spread`.

Функция `spread` имеет 3 аргумента:

* `df` -- дата фрейм
* `key` -- название столбца, который содержит ключи
* `value` -- название столбца, который содержит значения

```{r}
table2 %>%
    spread(key = type, value = count)
```

![](pictures/spread.png)

### Функция separate

Функция `separate` может разделить один столбец на несколько новых столбцов.

Она имеет 4 аргумента:

* `df` -- дата фрейм
* `col` -- название столбца, который нужно будет разделить
* `into` -- название новых столбцов (в виде массива)
* `sep` -- тип разделителя

Давайте посмотрим на набор данных `table3`. Мы сказали, что переменная `rate` содержит себе 2 переменные. Давайте разделим эту переменную на две новых.

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"))
```

![](pictures/separate.png)

Разделитель подбирается автоматически. Если все таки R не понимает какой разделитель можно его указать.

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), sep = "/")
```

Изначально наша переменная имела строковый тип, но две новые переменные имеют числовой. По умолчанию функция `separate` оставляет тип таким же. Если вы хотите, чтобы функция автоматически подобрала и установила новый тип, используйте аргумент `convert`. 

```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), convert = TRUE)
```

Делить можно не только по какому-то знаку, но и отступив сколько-то значений. Просто в аругменте `sep` поставьте размер отступа.

```{r}
table3 %>% 
  separate(year, into = c("century", "year"), sep = 2)
```

### Функция unite

Функция `unite` выполняет действие обратное функции `separate`. Она объединяет несколько столбцов в один столбец.

Функция `unite` имеет 5 аргументов:

* `df` -- дата фрейм
* `col` -- название новго столбца
* `sep` -- тип соединения
* `...` -- название столбцов, которые нужно объединить
* `remove` -- удалить ли изначальные столбцы

Давайте посмотрим на набор данных `table5`. Мы сказали, что нужно объединить переменные `century` и `year`. Давайте объединим эти переменные в одну.

```{r}
table5 %>% 
  unite(new, century, year)
```

По умолчанию соединитель это `_`. Поменяем его.

```{r}
table5 %>% 
  unite(new, century, year, sep = "")
```

![](pictures/unite.png)

Если изначальные переменные вам нужны, то можно оставить их с помощью аргумента `remove`.

```{r}
table5 %>% 
  unite(new, century, year, sep = "", remove = FALSE) 
```
