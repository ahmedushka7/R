---
title: "Пакеты lubridate, stringr и forcats"
author: "Зарманбетов Ахмед"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
    highlight: pygments
    #df_print: paged
editor_options: 
  chunk_output_type: console
---
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Пакет lubridate

<center>
![](pictures/lubridate.png){width=300px}
</center>

Как мы говорили ранее одним из типов переменных является *дата и время*. В R уже встроены основные функции для работы с датами. Это функции `as.Date` и `as.POSIXct`. Ими можно пользоваться, но они уже устарели. Поэтому был создан более функциональный пакет `lubridate` для работы с датами и временем. 

Подгрузим пакет `lubridate` . Также нам понадобится уже знакомый нам пакет `nycglights13` и пакет `dplyr`.

```{r}
# install.packages('lubridate')
# install.packages('nycflights13')
# install.packages('dplyr')
library('lubridate')
library('nycflights13')
library('dplyr')
```

### Создание переменных

Существует три типа данных, описывающих время:

* дата(`date`) -- календарная дата
* время(`time`) -- время суток
* дата и время(`dttm/POSIXct`) -- календарная дата + время суток

Мы будем говорить только о первом и третьем типе.

С помощью  функций `today` и `now` вы можете получить значения текущей даты или даты и времени.

```{r}
today()
now()
```

Создать переменную даты и времени можно с помощью следующих способов:

* на основе строковой переменной
* на основе индвидуальных компонент даты и времени
* на основе существующего объекта даты и времени

Рассмотрим каждый из них.

#### Создание переменных на основе строк

Этот способ очень часто используется, когда данные поступают в виде строковой переменной. Если вы работаете с датами, то вам нужно лишь определить в какой последовательности идет значение года, месяца и дня. В такой же последовательности нужно расставить буквы `y`,`m` и `d`. Это и будет название функции, на вход которой мы подаем строковую переменную.

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

На вход этим функциям можно подать и числовое значение.

```{r}
ymd(20170131)
```

Чтобы создать переменную даты и времени нужно добавить в имя функции символ нижнего подчеркивания и одну или несколько дополнительных букв `h`, `m` и `s`, которым соответствуют часы, минуты и секунды.

```{r collapse=TRUE}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

#### Создание переменных на основе отдельных компонент

Иногда вы будете располагать отдельными компонентами даты и времени, предоставленных в нескольких столбцах. Например такой вариант есть в фрейме данных `flights`.

```{r}
flights %>% 
  select(year, month, day, hour, minute)
```

В таком случае можно использовать функцию `make_date` для даты и `make_datetime` для даты и времени.

```{r}
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(departure_dt = make_datetime(year, month, day, hour, minute),
         departure_d = make_date(year, month, day))
```

#### Создание переменных на основе других типов

Иногда возникает необходимость перехода между значениями даты и даты/времени. Для этого можно использовать функции `as_datetime` и `ad_date`. 

```{r}
as_datetime(today())
as_date(now())
```

Иногда ваши исходные значения даты и времени могут быть заданы в виде количество секунд, которое прошло с 1 января 1970 года. В этом случае тоже можно использовать эти функции.

```{r}
as_datetime(60 * 60 * 10)
as_date(365 * 10 + 2)
```

### Компоненты даты и времени

Из переменных даты и времени можно выделять следующие компоненты:

* `year` -- год
* `month` -- месяц
* `mday` -- день месяца
* `yday` -- день года
* `wday` -- день недели
* `hour` -- час
* `minute` -- минута
* `second` -- секунда

```{r collapse=TRUE}
datetime <- ymd_hms("2016-07-08 12:34:56")
year(datetime)
month(datetime)
mday(datetime)
yday(datetime)
wday(datetime)
hour(datetime)
minute(datetime)
second(datetime)
```

Передав функциям `month` и `wday` аргумент `label = TRUE`, можно получить сокращенное название месяца или дня недели. Чтобы получить полное название можно задать аргумент `abbr = TRUE`.

```{r}
month(datetime, label = TRUE)
wday(datetime, label = TRUE, abbr = FALSE)
```

Компоненты можно так же менять.

```{r}
year(datetime) <- 2020
month(datetime) <- 01
hour(datetime) <- hour(datetime) + 1
```

Все изменения можно произвести за один раз с помощью функции `update`.

```{r}
update(datetime, year = 2020, month = 2, mday = 2, hour = 2)
```

Если значения слишком большие, они переносятся на следующие года, месяцы и так далее.

```{r}
ymd("2015-02-01") %>% 
  update(mday = 30)
ymd("2015-02-01") %>% 
  update(hour = 400)
```

### Временные промежутки

Над датами можно выполнять арифметические операции.

В R при вычитании двух дат вы получаете объект `difftime`.

```{r}
a_age <- today() - ymd(19980505)
a_age
```

Этот объект выводит промежутки, выраженные в секундах, минутах, часах, днях или неделях. Эта неоднозначность может несколько затруднять работу с объектами `difftime`. Поэтому лучше использовать функцию `as.duration`, которая приводит все в секунды, из которых вы можете получить то, что вам нужно.

```{r}
as.duration(a_age)
```

Чтобы получить число без надписей, можно использовать функцию `as.numeric`.

```{r}
as.duration(a_age) %>% as.numeric()
```

## Пакет stringr

<center>
![](pictures/stringr.png){width=300px}
</center>

Пакет `stringr` предназначен для работы со строками. Мы знакомы со строковым типом с самого первого занятия, но никаких операций с ним делать не можем. Если только функции `paste` и `paste0`.

```{r}
# install.packages('stringr')
library('stringr')
```

Помним, что для создания строки нужно использовать кавычки.

```{r}
h <- "Hello world!"
```

Все функции в пакете `stringr` начинаются с **str_**. Это очень удобно, вы можете написать **str_**, потом нажать *Tab* и вам будут показаны функции из пакета  `stingr`.

### Длина строки

Функция `str_length` показывает длину строки. Может работать как с одной строкой, так и с массивом строк.

```{r}
str_length('Hello')
str_length(c('Hello', 'world', '!', NA))
```

### Объединение строк

Функция `str_c` обьединяет две или большее число строк.

```{r}
str_c('x', 'y')
```

Можно использовать аргумент `sep`, чтобы задать символ склеивания.

```{r}
str_c('x', 'y', sep = '-')
```

Если вы испольуете массив на входе, то следует использовать аргумент `collapse` для склеивания.

```{r}
str_c(c('x', 'y', 'z'), collapse = ', ')
```

Также можно использовать "зацикливание".

```{r}
str_c('prefix-', c('x', 'y', 'z'), '-suffix')
```

### Извлечение подстрок

Чтобы извлечь подстроку можно использовать функцию `str_sub`, которая имеет аргументы `start` и `end`, которые задают начало и конец подстроки.

```{r}
str_sub('Hello', start = 2, end = 4)
```

Можно использовать в качестве аргумента не строку, а массив.

```{r}
str_sub(c('Hello', 'world'), start = 2, end = 4)
```

### Регистр

Следующие функци позволяют менять регистр букв:

* `str_to_lower` -- нижний регистр
* `str_to_upper` -- верхний регистр
* `str_to_title` -- каждое слово начинается с большой буквы

```{r collapse=TRUE}
str_to_lower('HELLO WORLD!')
str_to_upper('hello world!')
str_to_title('hello world!')
```

### Удаление пробелов

Функция `str_trim` удаляет пробелы слева и справа.

```{r}
str_trim('   Hello world!   ')
```

### Регулярные выражения

Регулярные выражения -- это язык, позволяющий описывать строковые шаблоны. Их вид ужасает, но они очень удобны! С помощью них вы можете находить в строке то, что вам нужно.

Используем функцию `str_view` для демонстрации. На вход она принимает символьный ветор и регулярное выражение.

Начнем с простого. Найдем выражение, которое содержится в слове (неважно где).

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "an")
```

Добавим точку (`.`) Вместо неё может быть любой символ, кроме символа перевода строки(`\n`).

```{r}
str_view(x, ".a.")
```

Но если точке соотвествует любой символ, то какому шаблону будет соотвествовать сам символ точки (`.`). В регулярных выражениях для этого используется обратный слеш (`\`). То есть нужно использовать `\.`. Но для создания регулярного выражения нужно использовать опять обратный слеш.

```{r}
str_view(c("abc", "a.c", "bef"), "a\\.c")
```

Так называемые якоря:

* `^` to match the start of the string.
* `$` to match the end of the string.

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "^a")
str_view(x, "a$")
```

Используем оба "якоря", чтобы выделить выражения, которые содержат только нужное нам слово.

```{r}
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")
str_view(x, "^apple$")
```

Мы уже использовали символ точки (`.`). Изучим другие символы:

* `\d` -- совпадает с любой цифрой
* `\s` -- совпадает с любым пробельным символом(пробел, символ табуляции(`\t`), перевод строки(`\n`))
* `[abc]` -- совпадает с `a`, `b` или `c`
* `[^abc]` -- совпадает с любым сиволом, кроме `a`,`b` или `c`

Также можно использовать логический оператор ИЛИ (`|`) для выбора одного из значений. Лучше такие выражения писать в круглых скобках.

```{r}
x <- c('Hello world!', 'Hi world!', 'Привет мир!')
str_view(x, "^(Hello|Привет)")
```

Остановимся на этом! Регулярных выражений очень много и с ними достаточно тяжело иметь дело в самом начале. 

### Функции для использования регулярных выражений

Функция `str_detect` дает логический ответ на вопрос, есть ли шаблон, который соотвествует регулярному выражению в строке. 

```{r}
x <- c('apple', 'banana', 'pear')
str_detect(x, 'e')
```

В пакете `stringr` есть массив, состоящий из 1000 английских слов. Он называется `words`. Потренируемся на нем. Найдем количество слов, которые начинаются с `t`.

```{r}
sum(str_detect(words, "^t"))
```

Или найдем долю слов, которые заканчиваются на гласную.

```{r}
mean(str_detect(words, "[aeiou]$"))
```

Функция `str_replace` может заменить совпадения новыми строками.

```{r}
x
str_replace(x, "[aeiou]", "-")
```

Эта функция заменяет только первое совпадение. Все совпадения можно заменить с помощью функции `str_replace_all`.

```{r}
str_replace_all(x, "[aeiou]", "-")
```

## Пакет forcats

<center>
![](pictures/forcats.png){width=300px}
</center>

```{r}
# install.packages('forcars')
library(forcats)
```

Пакет `forcats` создан для работы с факторными переменными. Если вам вдруг придется работать с ними, то ищите информацию в этом пакете :)