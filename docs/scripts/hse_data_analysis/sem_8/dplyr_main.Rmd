---
title: "Манипуляции с данными с помощью пакета dplyr"
author: "Зарманбетов Ахмед"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
    highlight: pygments
    #df_print: paged
editor_options: 
  chunk_output_type: console
---
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

### Пакет dplyr и набор данных flights

<center>
![](pictures/dplyr.png){width=200px}
</center>

На прошлом занятии мы поговорили о том, откуда можно взять данные, и как их импортировать. Но почти всегда данные приходят не в том виде, в котором нам хотелось бы. Поэтому перед тем как приступать к визуализации или построению модели, нужно обработать наши данные. В этом нам поможет пакет `dplyr`, который входит в библиотеку `tidyverse`.

Мы рассмотрим основные функции этого пакета:

* `filter`
* `arrange`
* `select`
* `mutate`
* `summarize`
* `group_by`

Функции из этого пакеты мы будем использовать на датасете `flights`, который находится в пакете `nycflights13`.В этом датасете содержится информация о всех авиарейсах аэропортов Нью-Йорка, совершенных в 2013 году. Описание датасета можно получить выполнив команду `?flights`.

Давайте подгрузим наши пакеты .

```{r}
# install.packages('dplyr')
# install.packages('nycflights13')
library('dplyr')
library('nycflights13')
```

Посмотрим на наш датасет.

```{r}
glimpse(flights)
```

Значение некоторых переменных:

* `year`, `month`, `day` -- дата отправления
* `dep_time`, `arr_time` -- aактическое время отправления и прибытия (формат HHMM или HMM)
* `sched_dep_time`, `sched_arr_time` -- запланированное время отправления и прибытия (формат HHMM или HMM)
* `dep_delay`, `arr_delay` -- задержка вылета и прилет (в минутах)
* `carrier` -- сокращенное название авиакомпании (в датасете `airlines` можно найти полное название)
* `flight` -- номер рейса
* `tailnum` -- номер самолета (в датасете `planes` можно узнать больше о самолете)
* `origin`, `dest` -- сокращенное название аэропорта отбытия и прибытия
* `air_time` -- общее время в воздухе (в минутах)
* `distance` -- дистанция между аэропортами в милях

А теперь начнем изучать возможности пакета `dplyr`!

### filter

С помощью функции `filter` вы можете отбирать наблюдения по каким-то критериям. Первым аргументом функции является название датасета (*df*). Последующие аргументы это логические выражения, которые обеспечивают отбор (фильтрацию). Давайте попробуем использовать эту функцию на практике.

```{r}
filter(flights, month == 1)
```

Данная функция на выходе выдаёт *df* c авиарейсами, которые были совершены в январе. Наше логическое выражение строится следующим образом: выбираем название колонки и сравниваем его с какими-либо значения. Важно отметить, что названия колонок не находятся в кавычках. 

Чтобы эффективно пользоваться данной функцией, нужно вспомнить **операторы сравнения**:

* `>` -- больше
* `<` -- меньше
* `>=` -- больше или равно
* `<=` -- меньше или равно
* `==` -- равно
* `!=` -- не равно

Вы можете смело использовать их для составления логических выражений. Помним, что один знак равно (`=`) -- это оператор присваивания, а два знака равно (`==`) -- оператор сравнения.

Функция не поменяла датасет `flights`. Если вы хотите запомнить результат, то вам нужно присвоить его какой-нибудь переменной.

```{r}
flights_jan <- filter(flights, month == 1)
```

Помним, что при сравнении могут возникнуть некоторые проблемы, связанные с точностью.

```{r collapse=TRUE}
0.1 + 0.2 == 0.3
1/49 * 49 == 1
```

Чтобы избежать такого рода проблемы лучше использовать функцию `near` вместо `==`.

```{r collapse=TRUE}
near(0.1 + 0.2, 0.3)
near(1/49 * 49, 1)
```

Если передавать функции `filter` несколько аргументов, то мы увидим только те наблюдения, которые удовлетворяют всем условиям, то есть будет использоваться логический оператор `И`. 

```{r}
filter(flights, month == 1, day == 1)
```

Давайте вспомним основные логические операторы:

* `И` -- наблюдения, которые удовлетворяют всем условиям (`&`).
* `ИЛИ` -- наблюдения, которые удовлетворяют хотя бы одному условию (`|`).
* `НЕ` -- наблюдения, которые не удовлетворяют данному условию (`!`).
* `XOR` -- наблюдения, которые не удовлетворяют обоим условиям, то есть дополнение к `И` (`xor()`).

**НЕЛЬЗЯ** использовать `&&` и `||`, которые мы привыкли использовать ранее.

Посмотрим как ими можно пользоваться.

```{r}
filter(flights, month == 5 | month == 6)
```

Данный запрос выведет все авиарейсы за май и июнь. Важно понимать, что записывать запрос таким образом: `filter(flights, month == 5|6)` **НЕЛЬЗЯ**!.

Когда значений для одного столбца достаточно много, то не очень удобно записывать все это для каждого значения. На помощь приходит выражение `%in%`. Его можно использовать как в коде, так и в работе с данными. Ниже можно увидеть два одинаковых выражения, но второе намного приятнее.

```{r eval=FALSE}
filter(flights, month == 5, month == 6, month == 8, month == 12)
filter(flights, month %in% c(5, 6, 8, 12))
```

Старайтесь не создавать сложные запросы. 

```{r}
filter(flights, !(arr_delay > 120 | dep_delay > 120))
```

Данный запрос выводит все авиарейсы с зарержкой не более 2 часов (как по прибытию, так и по отправке). Запрос выглядит очень сложно. Старайтесь этого избегать. Например, если вспомнить законы де Моргана из дискретной математики, то можно его упростить.

```{r}
filter(flights, arr_delay<=120, dep_delay <= 120)
```

Важно также разобраться с отсутствующими значениями (`NA`).  Чтобы проверить является ли значение равным `NA`, нужно использовать функцию `is.na`. C помощью этой функции можно убрать наблюдения, по которым у нас нет данных.

```{r}
filter(flights, !is.na(arr_delay))
```

### arrange

С помощью функции `arrange` вы можете отсортировать ваш датафрейм. Первым аргументом функции является название датасета (*df*). Последующие аргументы это названия столбцов, по которым идет сортировка.

```{r}
arrange(flights, year, month, day)
```

С помощью такого запроса мы отсортировали сначала года, потом месяцы для каждого года, а потом дни в каждом месяце. Порядок аргументов здесь очень важен! Можно убедиться на примере ниже.

```{r}
arrange(flights, month, day, year)
```

Если вы хотите отсортировать по убыванию, то можете использовать функцию `desc`.

```{r}
arrange(flights, desc(year))
```

Важно знать, что отсутствующие значения (`NA`) будут находиться в самом конце после сортировки.

### select

Часто бывает, что в данных очень много переменных, но вам нужны только некоторые. С помощью функции `select` вы можете сделать это. Первым аргументом функции является название датасета (*df*). Последующие аргументы это переменные (название стобцов), которые вам нужны.

С помощью запроса ниже мы выбрали переменные:

* `year`
* `month`
* `day`

```{r}
select(flights, year, month, day)
```

А с помощью такого мы выбрали все переменные, которые находятся между `year` и `day`.

```{r}
select(flights, year:day)
```

Аналогичный запрос, но с индексами столбцов.

```{r}
select(flights, 1:3)
```

Если вы хотите увидеть все столбцы за исключением каких-то, то можно воспользоваться знаком `-`.

```{r}
select(flights, -(year:day))
```

Такие запросы можно комбинировать. Можно взять первые десять столбцов за исключением 2.

```{r}
select(flights, 1:10, -2)
```

Когда переменных очень много, то такой способ становиться неудобным. На помощь приходят вспомогательные функции:

* `starts_with('abc')` -- отбирает столбцы, которые начинаются c *abc*.
* `ends_with('xyz')` -- отбирает столбцы, которые заканчиваются на *xyz*.
* `contains('ijk')` -- обирает столбцы, которые содержат последовательность символов *ijk*.
* `matches('(.)\\1')` -- обирает столбцы, которые удовлетворяют *регулярному выражению*.
* `num_range("x", 1:5)` -- отбирает столбцы с названием `x1`, `x2`, `x3`, `x4`, `x5`.
* `one_of(vars)` -- выбирает столбцы, название которых находится в векторе `vars`. Если какого-то столбца нет, то выдаст предупреждение, но не ошибку(если бы мы не использовали функцию).

Более подробно об этих и других вспомогательных функциях можно узнать с помощью команды `?select_helpers`.

Давайте попробуем их применить. Допустим нам нужные только данные, которые связаны с прилётом.

```{r}
select(flights, contains('arr'))
```

Появился лишний столбец `carrier`, но нам уже проще работать с таким датасетом (*df*).

Есть еще одна вспомогательная `everything()`. Она помогает перенести некоторые переменные в начало датафрейма. Это бывает удобно, если вы хотите сохранить переменные, но изменить их порядок. Давайте перенесем переменные `air_time` и `time_hour` вперёд, а остальные переменные пойдут за ними.

```{r}
select(flights, air_time, time_hour, everything())
```

С помощью функции `select` можно переименовать переменные, но при этом останутся только те переменные, которые вы переименовали.

```{r}
select(flights, Год = year)
```

Для того, чтобы переименовать какой-то столбец, но оставить все остальные, можно использовать функцию `rename`.

```{r}
rename(flights, Год = year)
```

### mutate

С помощью функции `mutate` вы сможете создавать новые переменные, основанные на уже существующих. Первым аргументом функции является название датасета (*df*). Последующие аргументы выглядят следующим образом:

> название новой переменной = операции с существующими переменными

Новые переменные добавляются в конец df. Поэтому давайте уменьшим наш df, чтобы мы могли увидеть новые переменные.

```{r}
flights_sml <- select(flights, year:day,
                               distance,
                               air_time)
```

Давайте создадим переменную `speed`. Она будет показывать среднюю скорость самолёта.

```{r}
mutate(flights_sml, speed_ml = distance / air_time * 60)
```

Умножаем на 60, так как время дано в минутах. Данная скорость мили/час. На только что созданные переменные можно сразу же ссылаться. Давайте найдем скорость км/час.

```{r}
mutate(flights_sml, speed_ml = distance / air_time * 60,
                    speed_km = speed_ml * 1.61)
```

Если вы хотите выделить только те переменные, которые только создали вы можете использовать функцию `transmute`. 

```{r}
transmute(flights_sml, speed_ml = distance / air_time * 60,
                    speed_km = speed_ml * 1.61)
```

Существует много функций для создания новых переменных. Все они должны быть векторизованы. Ознакомимся с основынми функциями.

Арифметические операторы:

* `+` -- сложение
* `-` -- вычитаение
* `*` -- умножение
* `/` -- деление
* `^` -- возведение в степень
* `%/%` -- целочисленное деление
* `%%` -- взятие остатка

```{r}
mutate(flights_sml, air_time/60)
```

В наборе данных `flights` из столбца `dep_time` можно извлечь часы и минуты.

```{r}
transmute(flights,
  dep_time,
  hour = dep_time %/% 100,
  minute = dep_time %% 100
)
```

Логарифмические операторы:

* `log()` -- натуральный логарифм
* `log2()` -- логарифм с основанием 2
* `log10()` -- логарифм с основанием 10

Полезно использовать, когда данные охватывают огромный диапозон.

```{r}
transmute(flights,
  distance,
  log_distance = log(distance)
)
```

Смещения:

* `lead()` -- ссылка на следующие значение
* `lag()` -- ссылка на предыдущее значение

```{r}
x <- 1:10
lag(x)
lead(x)
```

Удобно находить доли `x - lag(x)` или определять изменилось ли значение `x != lag(x)`. Удобно использовать с функцией `group_by`, о которой поговорим далее.

Кумулятативные и скользящие агрегаты:

* `cumsum()`
* `cumprod()`
* `cummin()` 
* `cummax()`
* `cummean()`

```{r}
x
cumsum(x)
cummean(x)
```

Если вы хотите находить скользящие в пределах "окна", то используйте пакет `RcppRoll`.

Логические операторы сравнения:

* `>` -- больше
* `<` -- меньше
* `>=` -- больше или равно
* `<=` -- меньше или равно
* `==` -- равно
* `!=` -- не равно

```{r}
mutate(flights_sml, air_time>120)
```

### group_by and summarize

Функция `summarize` позволяет свертывать набор данных в одну строчку. Например найти среднее по столбцу `dep_delay`.

```{r}
summarize(flights, delay = mean(dep_delay, na.rm = TRUE))
```

Также можно найти:

* `sum` -- сумму
* `min` -- минимальное значение
* `max` -- максимальное значение
* `mean` -- среднее значение
* `var` -- дисперсию
* `median` -- медиану
* `sd` -- среднеквадратическое отклонение
* `IQR` -- межквартильный размах
* `mad` -- медианное абсолютное отклонение
* `quantile(x, 0.25)` -- определенный квантиль(в данном примере 25%)
* `n()` -- количество элементов(можно использовать функцию `count`)
* `sum(!is.na(x))` -- количество элементов не равных `NA`
* `n_distinct` -- количество уникальных элементов
* `sum(x > 10)` -- количество элементов больше 10
* `mean(x == 0)` -- доля элементов равных 0 от общего количества

Эта функция не очень полезна, если используется не в связке с функцией `group_by`. Данная функция группирует данные по заданным переменным. Допустим мы хотим найти среднее значение задержки вылета для каждого дня.

```{r}
by_day <- group_by(flights, year, month, day)
summarize(by_day, delay = mean(dep_delay, na.rm = TRUE))
```

Можно устранить группирование с помощью функции `ungroup`.

### pipe(`%>%`)

Так называемый "канал" облегчает написание кода. Давайте поймем как он работает на простом примере. Предположим у нас есть массив `x` и мы хотим найти его среднее. Мы бы сделали это так.

```{r}
x <- 1:10
mean(x)
```

Но эту же операцию можно проделать с помощью **pipe** (`%>%`).

```{r}
x %>% mean()
```

Можно задаться вопросом, зачем делать так, а не как раньше? Давайте представим, что нам дан массив. Нам нужно возвести все элементы в квадрат, найти среднее, а потом взять от него корень. Это можно сделать 2 способами.

##### Вариант №1

```{r}
y <- x^2
z <- mean(y)
a <- sqrt(z)
```

##### Вариант №2

```{r}
y <- sqrt(mean(x^2))
```

У каждого варианта есть свои минусы. В первом случае кода очень много , и мы создаем очень много переменных. Во втором случае код короткий, но читать его очень неудобно. Все эти операции можно было сделать с помощью pipe(`%>%`).

```{r}
x %>% .^2 %>% mean() %>% sqrt()
```

Данный код убирает эти две проблемы. Его можно читать в повелительном наклонении слева направо. Заметим, что он заменяет первый аргумент функций. Это очень удобно использовать в пакете `dplyr`, так как первым аргументом функций является *df*.

Предположим, что мы проводим какие-то манимуляции с нашими данными, то есть применяем функции, которые мы изучили. К примеру выберем столбцы `year`, `month`, `day` и `dep_delay`. Отберем наблюдения где `dep_delay > 0`. Сгруппируем их по дням и найдем для каждого среднее значение `dep_delay`. 

```{r}
flights %>% select(year, month, day, dep_delay) %>%
            filter(dep_delay > 0) %>%
            group_by(year, month, day) %>%
            summarize(mean_dep_delay = mean(dep_delay, na.rm = TRUE))
```

### Полезные функции

#### count

> `count()` = `group_by()` + `n()`

Найдем количество перелетов за каждый день.

```{r}
flights %>%
  group_by(year, month, day) %>%
  summarize(n = n())
```

Это можно было сделать короче с помощью `count`.

```{r}
flights %>%
  count(year, month, day)
```

В `count` есть аргумент `sort`, который может отсортировать значения по убыванию.

```{r}
flights %>%
  count(year, month, day, sort = TRUE)
```

В `count` можно передавать логическое выражение. 

```{r}
flights %>% 
  count(dep_delay > 10)
```

#### top_n

Функция `top_n` может вывести лучший результат (или результаты) по каждой группе, основываясь на какой-то переменной. Давайте посмотрим на самую большую задержку вылета за каждый день.

```{r}
flights %>%
  select(1:3, dep_delay) %>%
  group_by(year, month, day) %>%
  top_n(1, dep_delay)
```

#### sample_n и sample_frac

Эти функции позволяют отобрать случайные наблюдения. 

```{r}
flights %>%
  sample_n(10)
```

```{r}
flights %>%
  sample_frac(0.01)
```

#### slice

Функция `slice` позволяет отобрать наблюдения по номеру строки, в которой они находятся. Напимер, отберем с 10 по 20 наблюдения.

```{r}
flights %>% slice(10:20)
```

#### distinct

Выдает датафрейм уникальных значений. Может принимать несколько переменных.

```{r}
flights %>% distinct(month)
```

```{r}
flights %>% count(month == 1)
```

