---
title: "Функции: решение заданий "
author: "Зарманбетов Ахмед"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
    highlight: pygments
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

**Все задачи оформляются в виде функции!**

### Задание №1

#### Условие

Даны 2 числа a и b. Нужно вывести на экран значение числа, которое больше.

#### Решение

```{r}
larger2 <- function(a, b){
  if (a > b) {
    return(a)
  }else{
    return(b)
  }
}

larger2(5, 10)
```

### Задание №2

#### Условие

Даны 3 числа: a,b и c. Нужно вывести на экран значение числа, которое больше.

#### Решение

```{r}
larger3 <- function(a, b, c){
  if (a > b) {
    if (a > c){
      return(a)
    }else{
      return(c)
    }
  }else{
    if (b > c){
      return(b)
    }else{
      return(c)
    }
  }
}
```

### Задание №3

#### Условие

Задан массив и числа a, b. Вывести все индексы переменных, где выполняется $a < x[i] < b$.

#### Решение

```{r}
IN <- function(x, a, b){
  l <- c()
  for (i in 1:length(x)) {
    if (a < x[i] && b > x[i]) {
      l <- c(l, i)
    }
  }
  return(l)
}

x <- c(9, -5, 4, 12, 7)
a <- 0
b <- 10
IN(x, a, b)
```

### Задание №4

#### Условие

Дан массив длинны n, состоящий из одних 0. Вы выбираете рандомное число от 1 до n(с помощью функции sample). Это рандомное число показывает индекс элемента массива, который нужно изменить с 0 на 1. После чего вы опять выбираете рандомное число. Это делается до тех пор пока массив не будет состоять из одних 1. Например: был массив с(0,0,0,0). Выпало рандомное число 3. Теперь массив выглядит так : c(0,0,1,0). Вы продолжаете так делать, пока все нули не исчезнут. Нужно посчитать, сколько раз выбиралось рандомное число.

#### Решение

```{r}
Com <- function(n){
  x <- rep(0, n) 
  i <- 0 # переменная, отвечающая за количество итераций
  while (sum(x) != n) {
    k <- sample(1:n, 1)
    x[k] <- 1
    i <- i + 1
  }
  return(i)
}

Com(6)
```

### Задание №5

#### Условие

В чем минус этой функции? Перепишите её.

```{r}
sq_or_cu <- function(x,y){
  if(y == 'Квадрат'){
    l <- x^2
    return(l)
  }else{
    l <- x^3
    return(l)
  }
}
```

#### Решение

```{r}
sq_or_cu <- function(x,y){
  if(y == 'Квадрат'){
    l <- x^2
    return(l)
  }
  if(y == 'Куб'){
    l <- x^3
    return(l)
  }
  return('Вы ввели неправильно переменную y!')
}
```

### Задание №6

#### Условие

Что можно сказать о следующем коде? Как бы вы его изменилил?

```{r}
f1 <- function(x){
  return(x^1)
} 
f2 <- function(x){
  return(x^2)
} 
f3 <- function(x){
  return(x^3)
} 
```

#### Решение

```{r}
f <- function(x, n){
  return(x^n)
}
```

### Задание №7 

#### Условие

Написать рекурсивную функцию для нахождения факториала.

#### Решение

```{r}
FACT <- function(n){
  if (n == 1) {
    return(1)
  }
  k <- FACT(n-1)
  return(k*n)
}

FACT(5)
```

### Задание №8

#### Условие

Давайте создадим функцию для игры. Есть принц, на старте игры у него есть `h` здоровья. Его цель -- забраться по лестнице на башню, где находится принцесса, которую нужно спасти от великана. Количество ступенек равно `m`. Двигается он по одной ступеньке вверх. Но с каждым продвижением наверх с вероятностью `p` его бьет по голове великан и герой теряет `z` здоровья и остается на прежней ступеньке. Нужно понять, сможет ли принц забраться на башню. Это означает, что принц должен забраться на башню и остаться живым.

Hints:

* Сколько параметров идет на вход?

* Чтобы замоделировать удар можно воспользоваться функцией `sample`, у которой есть параметр `prob`. Например можно бросить монетку, у которой вероятность выпадения орла равна 0.7.

```{r}
m <- sample(x = c('Орел', 'Решка'), size = 1, prob = c(0.7, 0.3))
```

* Задача циклична. Мы знаем два цикла: `for` и `while`. Знаем ли мы сколько придется делать итераций? От этого ответа и зависит выбор. 

* Пробуйте принтовать ваши параметры во время игры. Чтобы сделать это красиво, используйте функцию `paste`.

* Можно медленно наблюдать за ходом игры с помощью функции `readline()`. Это нужно, чтобы подобрать такие параметры, с которыми игра будет всегда разной.

#### Решение

```{r echo=FALSE, eval=FALSE}
prinz <- function(h, m, p, z) {
  current <- 0
  while (h > 0 && current < m) {
    kick <- sample(c('Ударил :(', 'Не ударил :)'), size = 1, prob = c(p, 1-p))
    print(kick)
    if (kick == 'Ударил :(') {
      h <- h - z
      if (current != 0) {
        current <- current - 1
      }
    }else{
      current <- current + 1
    }
    print(paste('Здоровья осталось', h))
    print(paste('Ступенька', current))
    print('--------------------')
    # readline('Нажмите Enter:')
  }

  if (h > 0){
    return(1)
  }else{
    return(0)
  }
}

prinz(100, 50, 0.25, 5) # хорошие параметры
```

### Задание №9

#### Условие

Решив предыдущую задачу, вы создали функцию, которая отвечает на вопрос: "Выиграл ли принц?". Запустив при некотрых параметрах эту функцию несколько раз, вы будете получать разные результаты. Как оценить вероятность того, что принц сможет спасти принцессу? В этом нам поможет давно знакомая нам формула:

\[
P = \frac{m}{n},
\]

где `m` - количество побед прица в `n` играх.

Hint:

* Сыграйте в игру например 100 раз. Для этого вам понадобится цикл :)

#### Решение

```{r echo=FALSE, eval=FALSE}
n <- 100 # количество игр
m <- 0 # 
for (i in 1:n) {
  m <- m + prinz(100, 50, 0.25, 5) # функция равна 1(победа) или 0(проигрыш)
}
print(paste("Вероятность победы:", m/n))
```
