---
title: "Функции"
author: "Зарманбетов Ахмед"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
    highlight: pygments
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Встроенные функции

### Зачем нужны собственные функции

Предположим у нас есть 3 массива. И нам нужно найти сумму каждого из них. Не зная, что такое функция, мы бы сделали следующим образом.

```{r}
m1 <- 1:5
m2 <- 3:6
m3 <- c(-10,0,9)

s1 <- 0
s2 <- 0
s3 <- 0

for(i in 1:length(m1)){
  s1 <- s1 + m1[i]
}

for(i in 1:length(m2)){
  s2 <- s2 + m2[i]
}

for(i in 1:length(m3)){
  s3 <- s3 + m3[i]
}

print(s1)
print(s2)
print(s3)
```

Если представить, что таких массивов будет болльше или мы будем находить не сумму, а что-то другое(где код будет гораздо больше),то возникает проблема: код занимает очень много места, хотя производится одна и та же операция, но с разными  входными данными. Для решения данной проблемы была придумана функция.

```{r}
SUM <- function(x){
  s <- 0
  for(i in 1:length(x)){
    s <- s + x[i]
  }
  return(s)
}

SUM(m1)
SUM(m2)
SUM(m3)
```

Код значительно уменьшился. Попробуем сделать функцию, которая выводит квадрат числа.

```{r}
f <- function(x){
  l <- x^2
  return(l)
}

f(5)
```


```{r}
# А теперь улучшим предыдущую фукцию. На вход будет подаваться число и строковая переменная,
# которая равна либо "Куб" , либо "Квадрат"

f <- function(x,y){
  if(y == 'Квадрат'){
    l <- x^2
    return(l)
  }else{
    l <- x^3
    return(l)
  }
}

f(3,y = 'Куб')

# У многих функций, есть дефолтные параметры. Они нужны, чтобы уменьшить написание
# входных переменных функции. 

f <- function(x,y = 'Квадрат'){
  if(y == 'Квадрат'){
    l <- x^2
    return(l)
  }else{
    l <- x^3
    return(l)
  }
}

f(2)
f(2, y = 'Куб')

# Внутри каждой функции используются какие-то дополнительные переменные. Но их значение
# используется только внутри функции, поэтому такие переменные называются локальными.
# Переменные, которые мы видим в правом верхнем окошке являются глобальными.
# Можно сделать переменную глобальной внутри функции(но лучше этого не делать)
rm(list=ls())
f <- function(x){
  l <<- x^2
  return(l)
}

f(5)

# Поработаем теперь с return. Важно, что должна выводить функция.

k <- function(x){
  a <- x*5
  b <- x/5
  c <- x+5
  return(a)
}

# Выводить можно несколько чисел, с помощью массива.

k <- function(x){
  a <- x*5
  b <- x/5
  c <- x+5
  return(с(a,b,c))
}

# Напишем функцию факториала.
fact <- function(n) {
  k <- 1
  for(i in 2:n){
    k <- k*i
  }
  return(k)
}

# Теперь поговорим про рекурсию. Рекурсия - это функция, которая использует саму себя.
fact1 <- function(n){
  if(n == 1){
    return(1)
  }else{
    k <- fact1(n-1)
    return(n*k)
  }
}


```


### Рекурсия