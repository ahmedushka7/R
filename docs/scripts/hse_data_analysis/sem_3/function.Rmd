---
title: "Функции"
author: "Зарманбетов Ахмед"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
    highlight: pygments
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Встроенные функции

### Зачем нужны собственные функции

Предположим у нас есть 3 массива. И нам нужно найти сумму каждого из них. Не зная, что такое функция, мы бы сделали следующим образом.

```{r}
m1 <- 1:5
m2 <- 3:6
m3 <- c(-10,0,9)

s1 <- 0
s2 <- 0
s3 <- 0

for(i in 1:length(m1)){
  s1 <- s1 + m1[i]
}

for(i in 1:length(m2)){
  s2 <- s2 + m2[i]
}

for(i in 1:length(m3)){
  s3 <- s3 + m3[i]
}

print(s1)
print(s2)
print(s3)
```

Если представить, что таких массивов будет болльше или мы будем находить не сумму, а что-то другое(где код будет гораздо больше),то возникает проблема: код занимает очень много места, хотя производится одна и та же операция, но с разными  входными данными. Для решения данной проблемы была придумана функция.

```{r}
SUM <- function(x){
  s <- 0
  for(i in 1:length(x)){
    s <- s + x[i]
  }
  return(s)
}

SUM(m1)
SUM(m2)
SUM(m3)
```

Код значительно уменьшился. Попробуем сделать функцию, которая выводит квадрат числа.

```{r}
f <- function(x){
  l <- x^2
  return(l)
}

f(5)
```


```{r}
# А теперь улучшим предыдущую фукцию. На вход будет подаваться число и строковая переменная,
# которая равна либо "Куб" , либо "Квадрат"

f <- function(x,y){
  if(y == 'Квадрат'){
    l <- x^2
    return(l)
  }else{
    l <- x^3
    return(l)
  }
}

f(3,y = 'Куб')

# У многих функций, есть дефолтные параметры. Они нужны, чтобы уменьшить написание
# входных переменных функции. 

f <- function(x,y = 'Квадрат'){
  if(y == 'Квадрат'){
    l <- x^2
    return(l)
  }else{
    l <- x^3
    return(l)
  }
}

f(2)
f(2, y = 'Куб')

# Внутри каждой функции используются какие-то дополнительные переменные. Но их значение
# используется только внутри функции, поэтому такие переменные называются локальными.
# Переменные, которые мы видим в правом верхнем окошке являются глобальными.
# Можно сделать переменную глобальной внутри функции(но лучше этого не делать)
rm(list=ls())
f <- function(x){
  l <<- x^2
  return(l)
}

f(5)

# Поработаем теперь с return. Важно, что должна выводить функция.

k <- function(x){
  a <- x*5
  b <- x/5
  c <- x+5
  return(a)
}

# Выводить можно несколько чисел, с помощью массива.

k <- function(x){
  a <- x*5
  b <- x/5
  c <- x+5
  return(с(a,b,c))
}

# Напишем функцию факториала.
fact <- function(n) {
  k <- 1
  for(i in 2:n){
    k <- k*i
  }
  return(k)
}




```


### Рекурсия

Вставить мем про рекурсию

```{r}
# Теперь поговорим про рекурсию. Рекурсия - это функция, которая использует саму себя.
fact1 <- function(n){
  if(n == 1){
    return(1)
  }else{
    k <- fact1(n-1)
    return(n*k)
  }
}
```

### Прочее

#####################
### Функции! 
#####################

x <- 14

if (x %% 2 == 0){
  print('Она чётная!')
} else {
  print('Она нечётная!')
}

# Это неудобно использовать много раз! 
# Чтобы было удобно, 
# можно написать функцию!

delenie <- function(x){
  
  if (x %% 2 == 0){
    print('Она чётная!')
  } else {
    print('Она нечётная!')
  }
}

delenie(15)
delenie(11)
delenie(883)

## Функция которая возводит в квадрат 
kvadr <- function(x, y){
  print(x^2 + y)
  # что надо отдать наружу:
  return(x^2 +y)
}

z <- kvadr(5, 3)
z

# Хочу x - число, y - указание что с ним делать!
Masha <- function(x, y){
  if(y == 'квадрат'){
    return(x^2)
  }
  if(y == 'куб'){
    return(x^3)
  } else {
    print('Ошибка: вы пишите что-то не то в y!')
  }
}

Masha(3, 'куб')
Masha(3, 'квадрат')
Masha(3, 'пельмени')

# Необязательный аргумент
Masha_2 <- function(x, y='куб'){
  if(y == 'квадрат'){
    return(x^2)
  }
  if(y == 'куб'){
    return(x^3)
  } else {
    print('Ошибка: вы пишите что-то не то в y!')
  }
}

# пока не выберем конкретный y, будет возводить в куб
Masha_2(3)
Masha_2(3, y='квадрат')

# Хочу много выходов!
yanix <- function(x, y){
  z1 <- x * y
  z2 <- x + y
  z3 <- x %% y
  return(c(z1, z2, z3)) # могу вернуть из функции массив
}

# могу записать массив в новую переменную 
xxx <- yanix(5,2) 
xxx[2] # и посмотреть что там лежит такого интересного

#####################
### Циклы! 
#####################

x <- c(7, 4, 5, 9, 18, 3)

# хочу умножить на 2 каждое!
x[1] <- 2*x[1]
x[2] <- 2*x[2]
x[3] <- 2*x[3]
#..... 

# вывожу на экран все элементы 
# length(x) - длина массива, тут она 6
for(i in 1: length(x)){
  print(x[i])
}

# задание: хочу распечатать только четные числа
for(i in 1:length(x)){
  # печатает чётные числа
  # if( x[i] %% 2 == 0){
  #   print(x[i])
  # }
  # элементы на чётных местах
  # if(i %% 2 == 0){
  #   print(x[i])
  # }
  # позиции для чётных элементов
  if(x[i] %% 2 == 0){
    print(i)
  }
}

# числа a,b, массив x
x <- sample(1:10, size = 10, 
            replace = TRUE)
a <- 4
b <- 8
# Вывести все позиции где a < x[i] < b
for(i in 1:length(x)){
  if((x[i] > a)&(x[i] < b)){
    print(i)
  }
}

#####################
### Сразу и циклы и функции!
#####################

# Есть массив x, хочу его сумму
x <- sample(1:10, size=10, replace=TRUE)

summator <- function(x){
  s <- 0
  for(i in 1:length(x)){
    s <- s + x[i]
  }
  return(s)  
}

summator(c(1,2,3))
summator(50:60)

# А теперь хочу произведение!
umnozator <- function(x){
  s <- 1
  for(i in 1:length(x)){
    s <- s * x[i]
  }
  return(s)  
}

umnozator(c(1,2,3))
umnozator(50:60)

# А теперь хочу либо сумму либо произведение в зависимости от того, что в y
superf <- function(x, y){
  if(y == 'сложить'){
    s <- summator(x)
    return(s)
  }
  if(y == 'умножить'){
    s <- umnozator(x)
    return(s)
  }
}

superf(c(4,9,18), 'умножить')
superf(c(4,9,18), 'сложить')

# хочу факториал!!!
fctrl <- function(n){
  q = 1
  for(i in 1:n){
    q = q * i
  }
  return(q)
}

fctrl(6)

# Почему очень плохо делать вот так:  
n = 10
s = 0
for(i in 1:n){
  s = s + fctrl(i)
}

# Ответ: потому что мы считаем заново одно и то же 
# 1! =             1
# 2! =         2 * 1 
# 3! =     3 * 2 * 1
# 4! = 4 * 3 * 2 * 1

# Как сделать оптимальнее???
hz <- function(n){
  q = 1
  s = 0
  for(i in 1:n){
    q = q * i
    s = s + q
  }
  return(s)
}
hz(7)

# придумываем решение задачки про карточки!
x <- c(1,5,7,9,2,3,4,8)
n = 9
summator(1:n) - summator(x)

