---
title: "Дополнительные фишки"
author: "Зарманбетов Ахмед"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
    highlight: pygments
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Обязательный материал

#### Короткая запись основных конструкций

Если вы хотите написать короткий условный оператор `if`, цикл `for`, цикл `while` или короткую функцию, то можно написать все в одну строчку без фигурных скобок.

```{r}
x <- 5
if (x == 5) print('Число равно 5.')
```

```{r collapse=TRUE}
for (i in 1:5) print(i)
```

```{r}
a <- 0
while (a < 5) a <- a + 1
print(a)
```

```{r}
s <- function(x) return(x^2)
s(4)
```

#### Встроенные функции для массива

Основные встроенные функции для массива:

1. `sort(x)` -- сортирует элементы массива по возрастанию.
2. `unique(x)` -- выводит уникальные элементы массива.
3. `sum(x)` -- находит сумму всех элементов массива.
4. `mean(x)` -- находит среднее всех элементов массива.

```{r collapse=TRUE}
x <- c(1, 2, 2, 3, 3, 5, 10)
sort(x)
unique(x)
sum(x)
mean(x)
```

#### paste

Иногда вы хотите соединить текст и значение переменной. Чтобы это сделать нужно использовать функцию `paste()`. В ней вы через запятую указываете, что вы хотите написать.

```{r}
x <- 5
print(paste('Число x равно:', x))
```

У функции также есть параметр `sep`. В него вы можете написать разделитель между тем, что написали.

```{r}
x <- 5
print(paste('Число x равно', x, sep = ':'))
```

#### %in%

Можно проверить находится ли какое-то значение в массиве.

```{r collapse=TRUE}
5 %in% c(1, 2, 5)
4 %in% c(1, 2, 5)
```

#### ifelse

Можно записать условную конструкцию `if` в виде функции `ifelse`.

```{r}
Age <- 16
ifelse(Age > 17, 'Adult', 'Teenager')
```

#### Название элементов массива

Элементам массива можно дать название.

```{r}
temperature <- c(7, 6, 3, -1, 0)
columns = c('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday')
names(temperature) <-  columns
temperature
```

С помощью функции `names()` эти названия можно получить.

```{r}
names(temperature)
```

#### readline

Изучим функцию `readline()`. Она используется для двух целей:

1. Можно интерактивно задавать переменные из консоли.

Запустите следующий код в скрипте.

```{r eval=FALSE}
a <- readline('Введите значение переменной a: ')
```

После запуска кода, R в консоли предложит ввести значение этой переменной. Это значение и присвоится переменной `a`.

2. Можно останавливать цикл на каждой итерации.

В некоторых ситуациях мы хотим останавливать цикл, чтобы смотреть как работает наш код.

Запустите следующий код в скрипте.

```{r eval=FALSE}
s <- 0
for (i in 1:10) {
  s <- s + i
  readline('Нажмите Enter, чтобы перейти к следующей итерации.')
}
```

С помощью такого кода можно отслеживать как меняется перменная `i` и переменная `s`.

### Необязательный материал

#### Функция nchar

Функция `nchar()` покажет нам количество символов в строке. Она работает как функция `length()`, но только для строк.

```{r}
w <- 'Hello world!'
nchar(w)
```

#### next и break

##### next

Используя цикл, иногда, вы хотите сразу перейти к следующей итерации. Допустим мы принтуем числа от 1 до 10. Если число равно 5, то вы не хотите его принтовать, а хотите сразу перейти к числу 6. Для этого и нужен `next`.

```{r collapse=TRUE}
for (i in 1:10) {
  if (i == 5) {
    next  
  }
  print(i)
}
```

`next` можно использовать и в цикле `while`.

##### break

Иногда, вы используете цикл, и хотите выйти из него раньше.  То есть прекратить действие цикла. Для этого используется `break`. Допустим, у нас есть массив. Мы хотим суммировать его элементы. Но так же у нас есть порог `p`. Если мы на очередной итерации суммирования превысим этот порог, то дальше можно не считать, то есть цикл останавливается.

```{r}
x <- 1:10
p <- 9
s <- 0
for(i in 1:length(x)) {
  s <- s + x[i]
  if (s > p) {
    break
  }
}
```

`break` можно использовать и в цикле `while`.

#### else if

Сначала проверяется условие внутри `if`. Если оно не выполняется, то проверяется условие внутри `else if`. Если не выполняется ни одно из условий, то выполняется код указанный после `else`.

```{r}
Age <- 12
if (Age < 10){
  print('Child')
  print(Age)
} else if (Age > 17) {
  print('Adult')
  print(Age)
} else {
  print('Teenager')
  print(Age)
}
```

#### Элементы массива по условию

С помощью сравнения, можно получить логический вектор.

```{r}
x <- -3:3
x == 3
x < 0
```

С помощью логического вектора можно вывести только те элементы, которые удовлетворяют условию. 

```{r}
x[x == 3]
x[x < 0]
```

#### Матрицы

Матрицы можно задавать и без параметра `ncol` или `nrow`. 

```{r}
matrix(1:9, byrow = TRUE, nrow = 3)
```

Имена колонкам и строкам можно дать с помощью функций `rownames()` и `colnames()`.

#### stop

При использовании встроенных функци, могли возникать какие-то ошибки. Например, вызовем функцию `sum()` для строковой переменной.

```{r error=TRUE}
sum(c('Hello', 'world'))
```

При создании собственных функци, можно так же создавать ошибки с помощью функции `stop`.

```{r error=TRUE}
SUM <- function(x) {
  if (!is.numeric(x)) {
    stop('В массиве содержатся не числа!')
  }
  s <- 0
  for (i in 1:length(x)) {
    s <- s + x[i]
  }
  return(s)
}

SUM(c('Hello', 'world'))
```

#### warning

По аналогии с функцией `stop` есть функция `warning`. В которой можно писать какие-либо предупреждения.